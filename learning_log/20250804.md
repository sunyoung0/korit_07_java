# 금일 수업 안내
ch09_classes -> products Product / ProductMain 클래스 생성

# Getter / Setter
## Getter / Setter 의 필요성
1. 문제 상황
    - 클래스를 하나 만든다고 가정하겠습니다. 예를 들어, Person 클래스를 생성하면서
    이름, 나이 등의 정보를 저장하기 위해 필드를 선언합니다.
```java
public class Person {
    String name;
    int age;
}

public class PersonMain {
    public static void main(String[] args) {
        // Person 객체 생성
        Person person1 = new Person();  // 기본 생성자는 default 생성됨
        person1.name = "김일";
        // 객체명.속성명 = 데이터;
        person1.age = -10;

        System.out.println(person1.name);   // 결과값 : 김일
        System.out.println(person1.age);    // 결과값 : -10
    }
}
```
이상의 코드를 확인 했을 때, 나이에 정상적이지 않은 값이 대입되어 있습니다.
이처럼 외부(다른 클래스)에서 직접 속성값을 대입하게 될 때, 이상한 값이 들어가더라도
통제할 수 있는 방법이 없다는 문제가 있습니다.

-> 이상을 해결하기 위한 방법이 getter / setter 개념입니다.

## Getter / Setter 란?
1. Setter
   - 데이터를 '설정'하는 역할의 'method.' 클래스 외부에서 필드를 직접 수정하지
     못하도록 막고, 특정 메서드를 경유하여 값을 전달받아 '초기화 및 수정'을 하도록 함
2. Getter
   - 데이터를 '조회'하는 역할의 'method.' 클래스 외부에서 필드를 직접 읽지 못하도록 막고,
     특정 메서드를 경유하여 안전하게 값을 '반환(return)'하도록 함.
3. 장점
   1. 데이터 보호 - 변수가 private 접근제어자(수업예정)를 사용하여 외부에서 직접 접근하지 못하게 함으로써
                  데이터를 보호할 수 있음.
   2. 데이터의 유효성 검증(아까 -10을 걸러내는 부분을 의미)
        - Setter 메서드에서 입력된 데이터가 적합한지 확인하고, 잘못된 값을 거절할 수 있음
   3. 캡슐화(Encapsulation)
        - 데이터를 숨기고 필요한 경우에만 제한적으로 접근할 수 있도록 하여 클래스 내부 구현을 외부로 노출하지 않음.
   4. 유연성 증가
        - 나중에 요구사항이 바뀌어 데이터를 설정하거나 조회하는 방법이 변경되더라도
          클래스(Main 말고) 내부의 메서드만 수정하면 되므로 유지 보수가 쉬워짐.
      
## Setter / Getter 의 구조
### Setter 
```java
접근지정자_void_set속성명1(자료형 변수명) {
    this.속성명1 = 변수명;
}

public void setName(String name) {
    this.name = name;
}
```

### Getter
```java
접근지정자_자료형_get속성명1() {
    return 속성명1;
}

public int getAge() {
    return age;
}
```

### - Setter를 기준으로 데이터 유효성 검증 예시
```java
public class Person {
    // 필드선언
    int age;
    
    public void setAge(int birth) {
        if (birth < 0 || birth > 200) {
            System.out.println("불가능한 나이 입력입니다.");
            return; // method 에서 return은 즉시 종료 키워드입니다.
                    // 즉 이 이하로는 아예 실행되지 않음
        }
        System.out.println("변경 전 나이 : " + age); // birth 대입 전
        this.age = birth;
        System.out.println("변경 후 나이 : " + age); // birth 대입 후니까 동일한 코드라도 다른 결과값
    }
}

public class PersonMain {

    public static void main(String[] args) {
        Person person = new Person("김사", 54);
        
        person.setAge(789);                // 결과값 : 불가능한 나이 입력입니다.
        System.out.println(person4.age);    // 결과값 : 54 -> 기존 나이 출력됨
        person.age = 789;                  // 필드에 값을 직접 대입
        System.out.println(person4.age);    // 결과값 : 789

        // 이상과 같이 특정 방법을 사용하면 부정확한 데이터의 입력이 가능하기 때문에
        // 장기적으로는 method를 통한 데이터의 입력 / 수정 / 조회가 필요함.

        // .length()    -> String 자료형의 글자수를 return 하는 method, return 자료형은 int
        System.out.println(person.name.length());  
        // 객체명.메서드명().메서드명() 등으로 .이 여러개 나오는 방식을 chaining 이라고 함
    }
}
```

---

# 접근 지정자 (Access Modifier)
## 정의
- 클래스, 필드, 변수, 메서드의 접근 범위를 제어하는 키워드
- 사용 이유
  - 정보 은닉(캡슐화 : Encapsulation)을 실현하고, 코드의 보안성과 유지보수성을 위해

## 접근 지정자의 종류
1. public - 모든 클래스에서 접근 가능
   - setter / getter를 alt + ins를 통해서 생성하게 되면 public 이라는 것을 확인할 수 있습니다.
     애초에 다른 클래스에서 사용하라고 만드는 것이기 때문에 기본적으로 public 접근 지정자로 생성됩니다.
2. protected - 같은 패키지 내의 클래스 및 이 클래스를 상속받은 자식 클래스에서 접근 가능
   (상속은 추후 설명)
3. default - 접근 지정자를 명시하지 않으면 default로 간주되며, 같은 패키지 내의 클래스에서 접근 가능
4. private - 같은 클래스 내에서만 접근 가능
           - 그래서 저희는 앞으로 웬만하면 private 접근 지정자를 사용할 예정입니다.

```java
class Person {
    private String name;

    // setter / getter는 default로 접근제어자가 public 이므로 클래스 외부에서 사용 가능 
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class PersonMain {

    public static void main(String[] args) {
        // 객체 생성
        Person person1 = new Person();

        // System.out.println(person1.name);
        // Person 클래스에서 name이 private로 생성되어 있기 때문에 PersonMain 클래스에서는 위와 같은 형태로 사용이 불가능
        // 따라서 접근 지정자가 public인 setter, getter를 사용해야함 getter를 사용하면 데이터의 가공 가능
        person1.setName("김일");
        System.out.println(person1.getName());
    }
}
```

### - bank 예시문제
```java
public class Bank {
    private int accountNum;
    private String accountHolder;
    private int balance;
    private int pinNumber;

    public Bank(int accountNum, String accountHolder, int balance, int pinNumber) { //AllArgsConstructor 생성자
        this.accountNum = accountNum;
        this.accountHolder = accountHolder;
        this.balance = balance;
        this.pinNumber = pinNumber;
    }

    public void setBalance(int balance) {   // setter 에서 유효성 검증
        // 0원 초과가 입금이 가능해야하므로
        if ( balance <= 0) {
            System.out.println("잘못된 입력입니다.");
            return;
        }
        this.balance = balance;
    }
    
    public void showAccountInfo() {
        System.out.println("계좌 번호 : " + this.accountNum);
        System.out.println("계좌 소유자 : " + this.accountHolder);
        System.out.println("현재 잔액 : " + this.balance + "원\n");
    }

    public void deposit(int amount, int inputPin) {     // 입금 메서드
        if ( inputPin != this.pinNumber) {
            System.out.println("비밀번호가 틀렸습니다.");
            return;
        }

        if (amount <= 0) {
            System.out.println("불가능한 입력 금액입니다.");
            return;
        }
        this.balance += amount;
        System.out.println(amount + "원 입금 되었습니다! 현재 잔액 : " + this.balance + "원");

    }
    
    public void withdraw(int amount, int inputPin) {        // 출금 메서드
        if ( inputPin != this.pinNumber) {
            System.out.println("비밀번호가 틀렸습니다.");
            return;
        }

        if (amount <= 0) {
            System.out.println("불가능한 입력 금액입니다.");
            return;
        }

        if (amount <= this.balance) {
            this.balance -= amount;
            System.out.println(amount + "원이 출금 되었습니다 ! 현재 잔액 : " + this.balance + "원");
        } else {
            System.out.println("잔액이 부족하여 출금할 수 없습니다.");
        }
    }
}

public class BankMain {
    public static void main(String[] args) {
        Bank bank1 = new Bank(123456, "홍길동", 100000, 1234);

        bank1.deposit(50000, 1234);
        bank1.withdraw(100000, 1234);

        System.out.println("\n최종 계좌 정보");
        bank1.showAccountInfo();
    }
}
```