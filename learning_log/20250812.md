# Static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
- static 으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음' (해당 클래스의 인스턴스가 전부 동일한 값을 공유함을 의미)
- 클래스 자체에 속하게 됨
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분됩니다.

## 특징
1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를 공유하거나 상태를 저장할 때 유용.
2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메모리에 할당(객체가 생성될 때가 아니라)
    ```java
    @AllArgsConstructor
    public class KoreaItStudent07 extends KoreaItStudent {
        // 클래스 변수 선언
        private static String introduction = "코리아 아이티 국비 과정 7월";
        
        // 필드 정의
        private String name;
        private int age;
        private String address;
    //    private String introduction = "코리아 아이티 국비 과정 7월";
    }
    
    public class Main {
        public static void main(String[] args) {
            KoreaItStudent07 student1 = new KoreaItStudent07("김일", 20, "부산광역시");
        }
    }
    ```
    이상의 KoreaItStudent07 클래스의 인스턴스들은 전부 다 private static String '정적 변수'를 가지게 됩니다.
    즉, 어느 클래스의 인스턴스인지만 확인하더라도 몇 월 국비생인지 확인할 수 있습니다. (예를 들어 KoreaItStudent04의 객체는 코리아 아이티 국비 과정 4월이라는 private static String 정적 변수를 가지겠네요, 일일이 객체의 필드에 정의할 필요도 없구요)

3. 인스턴스가 필요 없음 : 객체를 생성하지 않고도 클래스명.필드 / 클래스명.메서드명() 형태로 직접 접근이 가능합니다.(필드는 private 접근 지정자가 아니어야합니다.)
4. 메모리 효율성 : static 변수는 프로그램이 종료될 때까지 한 번만 메모리에 할당됨.

### - 예시
- static 메서드의 호출은 객체를 생성하지 않은 시점에서도 가능
```java
@Setter
@Getter
public class Product {
    // 필드 선언
    private String name;
    
    @Getter     // 필드 레벨에서 추가적으로 설정한 어노테이션
    private static int count = 0;

    // 롬복을 사용하지 않은 static 메서드
    private static String title = "제품입니다.";

    public static String getTitle() { return title; }
    
    // 인스턴스 변수 수준의 field 정의
    private int instanceCount = 0;      // 필드 선언 및 초기화

    public Product() {
        System.out.println("Product 클래스의 인스턴스가 생성되었습니다.");
        instanceCount++;
        count++;
    }
}

public class ProductMain {
    public static void main(String[] args) {
        
        System.out.println(Product.getCount());     // 0
        Product product1 = new Product();
        System.out.println("일반 필드 조회 : " + product1.getInstanceCount());    // 1
        System.out.println("정적 필드 조회 : " + Product.getCount());             // 1

        Product product2 = new Product();
        System.out.println("일반 필드 조회 : " + product2.getInstanceCount());    // 1
        System.out.println("정적 필드 조회 : " + Product.getCount());             // 2

        Product product3 = new Product();
        System.out.println("일반 필드 조회 : " + product3.getInstanceCount());    // 1
        System.out.println("정적 필드 조회 : " + Product.getCount());             // 3
        
        // getInstanceCount()는 객체에 속해있음. 객체 생성 시에 한번 호출 됨.
        // 객체는 3개를 만들었지만 사실은 같은 객체이기 때문에 instanceCount는 계속 1임 
    }
}
```

---

# Singleton Pattern(싱글톤 패턴)
## 정의
소프트웨어 `디자인 패턴` 중 하나로, 어떤 클래스가 '하나의 인스턴스만 갖도록 보장하고,' 그 인스턴스에 접근할 수 있는 '전역적인 접근법'을 제공하는 패턴. 예를 들어, 데이터베이스 연결과 같은 리소스는 프로그램 전체에서 하나의 인스턴스만 사용해야 할 때가 많기 때문에 싱글톤 패턴을 사용함.

## 특징
1. 하나의 인스턴스만 존재 : 하나의 인스턴스만 생성되고, 이 인스턴스는 프로그램이 실행되는 동안 유지
2. 전역 접근법 : 싱글톤 인스턴스는 정적(static) 메서드를 통하여 어디서든 접근 가능
    -> 객체명.메서드명() x / 클래스명.메서드명();
3. 인스턴스의 생명주기 관리 : 클래스 자체가 인스턴스 생성을 관리하므로, 다른 객체들이 인스턴스를 생성하거나 폐기할 수 없음.

## 장점
1. 메모리 절약 : 불필요한 인스턴스 생성을 방지하여 메모리 절약 가능(static 변수 / 메서드의 장점과 같습니다.)
2. 글로벌(전역적) 접근 : 전역적 접근이 가능하여 메모리 관리가 용이 -> 다만 잦은 접근 자체는 단점
3. 일관성 유지 : 애플리케이션 전반에서 하나의 인스턴스만 사용하기 때문에 상태 일관성을 유지

## 단점 
1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용되므로 '단위 테스트'가 어려울 수 있음
2. 의존성 숨김 : 싱글톤을 남용하면 클래스 간의 의존성을 추적하기 어려울 수 있음

### - 예시
```java
public class ProductView {
    // 정적 변수 선언
    // 보통 싱글톤 패턴 만들 때 정적 변수 이름 -> instance
    private static ProductView instance;    // ProductView 클래스의 정적 field 인 instance, 자료형이 자기 자신
    private static int count = 1;

    // private 으로 생성자를 선언   -> 객체가 하나만 생성되는 걸 보장하기 위한 접근지정자이므로 매우 중요
    private ProductView() {
        int counter = 1;    // 객체 생성될 때 만들어지는 지역 변수
        System.out.println(counter +" 번 째 객체가 생성되었습니다.");
        counter++;
        System.out.println("정적 변수를 참조하는 " + count + "번 째 객체가 생성되었습니다.");
        count++;    // 위에 선언한 정적변수
    }

    // static 메서드의 정의 -> 대부분의 경우 getInstance() -> 클래스명.메서드명() 호출
    public static ProductView getInstance() {
        if (instance == null) {     // 현재 인스턴스가 없는 시점이라면 현재 코드라인이 true 이므로
            instance = new ProductView();   // ProductView() 생성자를 호출하여 instance에 대입
        }
        return instance;        // 이미 생성되어 있으면 바로 이 부분이 실행됨.
    }
}

public class ProductViewMain {
    public static void main(String[] args) {
        // ProductView.java 를 확인했을 때 객체를 생성하는 method
        // 생성자가 private 이라서 생성자를 호출하지 않음, 여러번 해도 객체는 한번만 생성 
        ProductView.getInstance();
        ProductView.getInstance();
        ProductView.getInstance();
    }
}
```
위의 코드를 실행했을 때 '1번째 객체가 생성되었습니다' 한줄만 출력됨
전에 static 배웠을 때는 '1, 2, 3번째 객체가 생성되었습니다'로 출력됨
-> 생성자 내에 지역 변수로 int counter을 선언하고 초기화했기 때문
```java
@AllArgsConstructor
@ToString
public class SmartPhone {
    // 필드 정의
    private String company;
    private String model;
    private String serial;

}

public class Samsung {
    private static Samsung instance;
    
    @Getter
    private String company;
    private int serialNumber;
    
    private Samsung() {    
        company = getClass().getSimpleName();       // 결과값 Samsung
        serialNumber = 20250000;                    
    }

    public static Samsung getInstance() {
        if (instance == null) {
            instance = new Samsung();
        }
        return instance;
    }

    public String createSerialNumber(String model) {
        return model + "_" + ++serialNumber;        
    }
}

@AllArgsConstructor
public class Factory {
    private String factoryName;

    public SmartPhone produceSmartPhone() {
        System.out.println(factoryName + "에서 스마트폰을 생산합니다.");

        String model = "갤럭시26";     // 지역변수
        String serial;

        Samsung samsung = Samsung.getInstance();
        serial = samsung.createSerialNumber(model);

        SmartPhone smartPhone = new SmartPhone(samsung.getCompany(), model, serial);

        return smartPhone;
    }
}

public class FactoryMain {
    public static void main(String[] args) {
        Factory factory1 = new Factory("제 1 공장");
        Factory factory2 = new Factory("제 2 공장");

        SmartPhone smartPhone1 = factory1.produceSmartPhone();
        System.out.println(smartPhone1);
        SmartPhone smartPhone2 = factory2.produceSmartPhone();
        System.out.println(smartPhone2);
    }
}
```

---

# 빌더 패턴 (Builder Pattern)
```java
@AllArgsConstructor
public class Student {
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private double[] scores;
}

public class StudentMain {
    Student student1 = new Student(여기 내부에 이상의 필드가 다 입력돼야합니다. 그런데, 순서대로);
}
```

# 빌더 패턴이 생기게 된 원인
1. 복잡한 생성자 문제
   - 객체의 필드가 많아질수록 생성자 파라미터 수도 늘어남.
     - 저희는 위의 예시에서 AllArgs만 정의했지만 매개변수 생성자를 종류별로 써야합니다.
     - 롬복을 도입했다고 하더라도 필수적인 것은 final 이나 @NonNull을 추가로 지정해줘야하고요.
2. 생성자 오버로딩 문제
    - 생성자에 필요한 조합이 다를 경우 수 많은 생성자들을 일일이 정의해야합니다.
    - 유지 보구세 악영향 / 필드 하나 추가하면 생성자를 다 뜯어고쳐야함.
      - RemoteController 작성할 때, VolumeDownButton을 추가하니까 main 단계에 있는 생성자에 필드 추가해줘야하고, 생성자 지웠다가 alt + ins 해서 다시 만들어주고 하는 귀찮은 과정들이 있었습니다.
3. 가독성과 유지 보수 문제
   - 코드를 작성하고 읽는 입장에서는 객체를 생성할 때 어떤 값이 어떤 필드에 해당하는지 명확하지 않아서 실수를 유발할 수 있음
```java
public static void main(String[] args) {
    Student student1 = new Student("김일" , "김이");
    // 라고 했을 때 김일 초등학교의 김이 학생인지 김일 학생이 김이 초등학교인지 알게 뭐냐는 문제가 있습니다.
}
```

## 정의
객체의 생성 과정에서 '복잡한 생성자'를 대신하여 객체를 '단계적으로' 생성할 수 있도록 도와주는 디자인패턴 중 생성 관련 파트.
GoF(Gang of Four) 디자인 패턴 중 하나로 객체 생성 시 가독성과 유연성을 제공하는 것이 목표.
    - 여기서 유연성의 의미는 필드를 순서대로 채워넣지 않고 순서를 바꾸더라도 제대로 알아서 필드에 들어간다는 것을 의미

```java
public class Student {
    private String name;
    private String school;
    
    public Student(String name, String school) {
        this.name = name;
        this.school = school;
    }
    public Student(String school, String name) {
        this.name = name;
        this.school = school;
    }
}
```

## 특징
1. 객체를 생성하는 여러 개의 필드를 '명시적'으로 관리할 수 있음.
2. 불필요한 생성자 오버로딩(위의 예시)을 줄여 가독성을 높임
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성
    - chaining method - 객체명.getClass().getSimpleName();이 예시였습니다.

### - 예시
```java
public class Person {
    private String name;
    private int age;
    private String address;

    private Person(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.address = builder.address;
    }
    
    public static class Builder {
        private String name;
        private int age;
        private String address;

        public Builder name(String name) {
            this.name = name;       
            return this;        
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Person build() {
            return new Person(this);        // 이 this는 Builder 클래스의 인스턴스에 해당
        }
    }
}

public class PersonMain {
    public static void main(String[] args) {
        // 빌더패턴 적용
        Person person1 = new Person.Builder().age(38).address("부산광역시 중구").name("박선영").build();
        System.out.println(person1);
        
        Person person2 = new Person.Builder().build();
        System.out.println(person2);

        Person person3 = new Person.Builder().address("서울특별시 종로구").build();
        System.out.println(person3);
    }
}
```

### - lombok을 쓴 예시
```java

@Builder
@ToString
public class PersonLombok {

    private String name;
    private int age;
    private String address;

}

public class PersonLombokMain {
    public static void main(String[] args) {
        PersonLombok person1 = PersonLombok.builder()
                .name("박선영")
                .age(26)
                .address("부산광역시 중구")
                .build(); 
        System.out.println(person1);

        PersonLombok person2 = PersonLombok.builder()
                .name("김이")
                .build();
        System.out.println(person2);
    }
}
```



