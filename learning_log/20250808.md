# 금일 수업 계획
- interface 복습
- casting
- objects
- git clone 관련 수업

---

### - interface 복습 - 에어컨 온도 조절 + 모드 변경 예시
```java
public class TemperatureUpButton extends Button {   // 온도 상승
    @Override
    public void onPressed() { System.out.println("온도를 한 칸 올립니다."); }
    public void onUpAirConditioner() { System.out.println("온도를 계속 올립니다."); }
}

public class TemperatureDownButton extends Button{  // 온도 하강
  @Override
  public void onPressed() { System.out.println("온도를 한 칸 내립니다."); }
  public void onDownAirConditioner() { System.out.println("온도를 계속 내립니다."); }
}

public class ModeChangeButton {
  private boolean change;

  public void modeChange() {
    if(change) {
      change = false;
      System.out.println("냉방으로 바꿉니다.");
    } else {
      change = true;
      System.out.println("난방으로 바꿉니다.");
    }
  }
}

public class AirConditionerController {
  private PowerButton powerButton;
  private TemperatureDownButton temperatureDownButton;
  private TemperatureUpButton temperatureUpButton;
  private ModeChangeButton modeChangeButton;
  
  public AirConditionerController(PowerButton powerButton,
                                  TemperatureDownButton temperatureDownButton,
                                  TemperatureUpButton temperatureUpButton,
                                  ModeChangeButton modeChangeButton) {
    System.out.println("에어컨 리모콘 객체가 생성되었습니다.");
    this.powerButton = powerButton;
    this.temperatureDownButton = temperatureDownButton;
    this.temperatureUpButton = temperatureUpButton;
    this.modeChangeButton = modeChangeButton;
  }

  public void onPressedPowerButton() { powerButton.onPressed(); }
  public void onPressedTemperatureDownButton() { temperatureDownButton.onPressed(); }
  public void onDownPressedTemperatureDownButton() { temperatureDownButton.onDownAirConditioner(); }
  public void onPressedTemperatureUpButton() { temperatureUpButton.onPressed(); }
  public void onUpPressedTemperatureUpButton() { temperatureUpButton.onUpAirConditioner(); }
  public void onPressedModeChange() { modeChangeButton.modeChange(); }
}

public class Main {
  public static void main(String[] args) {
    AirConditionerController airConditionerController = new AirConditionerController(
            new PowerButton(), new TemperatureDownButton(),
            new TemperatureUpButton(), new ModeChangeButton());

    airConditionerController.onPressedPowerButton();
    airConditionerController.onPressedTemperatureDownButton();
    airConditionerController.onDownPressedTemperatureDownButton();
    airConditionerController.onPressedTemperatureUpButton();
    airConditionerController.onUpPressedTemperatureUpButton();
    airConditionerController.onPressedModeChange();
    airConditionerController.onPressedModeChange();
    airConditionerController.onPressedPowerButton();
  }
}
```

# 참조 자료형 캐스팅(Reference Type Casting)
-객체 지향 프로그래밍(OOP)에서 중요한 요소 중 하나

## 사전 지식
- Java 상에서의 자료형은 크게 두가지로 구분됨.
    1. 기본 자료형(Primitive Type) : int, double, char, float, long
    2. 참조 자료형(Reference Type) : 객체를 참조하는 변수로, 클래스나 인터페이스로 생성된 객체

- 참조 자료형 캐스팅이란? - 객체의 자료형을 변환하는 작업.
- int -> double / int -> long 으로 변경하는 것은 형변환(conversion)이라고 했죠.

## 캐스팅 종류
1. UpCasting : 하위 클래스 타입의 객체를 상위 클래스 타입으로 변환
2. DownCasting : 상위 클래스 타입의 객체를 하위 클래스 타입으로 변환

## 미리 기억해두셔야 할 연산자(Operator) : instanceof
ex : 1 + 1 = 2 에서 +가 연산자 / = 대입 연산자인 것처럼,
ex : 객체명 instance0f 클래스명 -> return true / false (조건문에서 쓸 수 있음)

### UpCasting
- 암시적(implicit)으로 이루어짐
    - 알아서 바뀐다. 근데 언제 알아서 바뀌었는지는 개발자가 알고 있어야 함.

### DownCasting
- 명시적(Explicit)으로 이루어짐
  - 반드시 개발자가 적절한 장소와 시간대에 사용해야 한다.

## 업캐스팅과 다운캐스팅의 활용
- 캐스팅은 다형성(Polymorphism)을 구현할 때 사용. 상위 클래스 타입으로 객체를 처리하면서도 특정 상황에서는 하위 클래스의 고유 기능을 사용 가능

## 장단점
- 장점 : 
  - 코드 유연성 : 업캐스팅을 통해 '다양한 객체를 하나의 상위 클래스 타입으로 관리' 가능
  - 다형성 구현 : 메서드 오버라이딩과 함께 사용하면 코드의 재사용성 ↑
- 단점 :
  - 다운 캐스팅의 위험성 : 잘못 다운캐스팅을 하게 될 수 있음.
    - 상위 클래스 A와 하위 클래스 B, C가 있다고 가정할 때, B의 객체인 b를 A로 업캐스팅한 후에 C로 다운캐스팅을 하려고 시도하면 컴파일링 오류 발생.
  - 복잡성 증가 : 코드 가독성이 떨어질 수 있음.
    - 이렇게 바꿨다가 저렇게 바꿨다가 하기 때문인데 특히 업캐스팅의 경우 암시적으로 일어나기 때문에 어디서 이루어졌는지 확인 못하고 있다가 갑자기 명시적으로 작성하는 다운 캐스팅이 튀어나와서 초심자들이 코드 읽는게 어려워지는 경우가 발생할 수 있습니다.
  - 이상의 문제들을 해결하기 위한 연산자가 -> instanceof 입니다.
    코드 예시
```java
public static void main(String[] args) {
    System.out.println(objectA instanceof ClassA);  // 결과값 true / false
}
// objectA : 검사하려는 객체명
// ClassA : 객체가 검사될 클래스 / 인터페이스
```
- return 값은 objectA가 ClassA의 인스턴스이거나 '하위' 클래스의 인스턴스인 경우 true 아니면 false
- 클래스A 객체명 = new 클래스B();를 통해 객체를 생성했을 경우
  1. Override가 적용된 메서드, 즉 자식 클래스의 메서드가 호출됨.
  2. 클래스B(자식 클래스)의 고유 메서드는 호출 불가능

- 업캐스팅 - 객체명.메서드명(); 했을 때 재정의 버전이 나오는가 아닌가에 주목

### - 업캐스팅 / 다운캐스팅 예시
```java
public class Animal {       // 부모 클래스
    public void makeSound() { System.out.println("동물이 소리를 냅니다."); }
}

public class Dog extends Animal {   // 자식 클래스
  @Override
  public void makeSound() { System.out.println("개가 짖습니다."); }
  
  // Dog 클래스의 고유 메서드
  public void fetch() { System.out.println("강아지가 공을 물어옵니다."); }
}

public class Main {
  public static void main(String[] args) {
    // Dog 객체 생성, 오버라이드 한 makeSound()와 본인 고유 메서드 fetch() 사용 가능
    Dog dog1 = new Dog();
    dog1.makeSound();
    dog1.fetch();
        
    // 업캐스팅 # 1
    Animal animal1 = dog1;
    
    animal1.makeSound();
    // 결과값 : 개가 짖습니다. 즉 재정의된 method가 호출됨
    
    // animal1.fetch();     
    // 불가능 -> Animal 의 객체이기 때문에 dog 의 고유메서드 호출 불가
    
    // A a = new B();형태
    Animal animal2 = new Dog();    
    
    animal2.makeSound();    // 결과값 : 개가 짖습니다. 재정의된 method 호출
    // animal2.fetch();     // 불가능
    
    Animal animal3 = new Animal();
    animal3.makeSound();        // 결과값 : 동물이 소리를 냅니다. 본인 메서드
    
    // 연산자 instanceof 사용 사례
    boolean result1 = animal1 instanceof Animal;
    System.out.println(result1);    // true
    boolean result2 = animal1 instanceof Dog;
    System.out.println(result2);    // true
    
    // 업캐스팅이 이루어지지 않고 Dog dog1 = new Dog();로 만든 객체
    boolean result3 = dog1 instanceof Animal;
    System.out.println(result3);    // true
    boolean result4 = animal2 instanceof Dog;
    System.out.println(result4);    // true
    
    // animal3의 경우 Animal animal3 = new Animal();
    boolean result5 = animal3 instanceof Animal;
    System.out.println(result5);    // true
    boolean result6 = animal3 instanceof Dog;
    System.out.println(result6);    // false
    
    /*
        다운 캐스팅은 '명시적'으로 이루어져야 함
        방법 : (클래스명)객체명; -> (int)2.3;과 같은 방식 형변환의 객체버전
        그래서 기본 자료형의 형변환에서 벗어나서 참조 자료형까지 고려해야함
     */

    // 다운 캐스팅 방법
    Dog dog2 = (Dog) animal2;   
    
    dog2.makeSound();       // 결과값 : 개가 짖습니다.
    dog2.fetch();
    // dog2로 새로운 객체명을 선언하고 거기에 명시적 참조 자료형 캐스팅을 적용하여 Animal 클래스의
    // 인스턴스인 animal2를 다운캐스팅 했습니다.
    
    // Dog dog3 = (Dog) animal3;     // downCasting 을 하는 과정에서 오류 발생
    // dog3.makeSound();             // 호출 불가
    
    /*
        207번 라인에서 오류가 발생
        animal3를 생성할 때 Animal 클래스의 생성자를 호출해서 만들었기 때문에 (A a = new A();)
        하위 클래스의 인스턴스로 다운캐스팅하는 것이 불가능
     */
    
    // 위 오류를 해결하기 위해서는 A a = new B();형태로 
    // 선언된 클래스와 호출되는 생성자가 서로 달라야 하고 둘은 상속관계여야 함.
    Animal animal4 = new Dog();
    
    // 잘못 다운캐스팅이 이루어지는지에 대한 확인을 할 수 있는 방법 -> instanceof 연산자

    // (animal4 instanceof Dog) 조건식이 true 라면 animal4의 생성시 호출된 생성자는 Dog();
    // 그러므로 225번 라인의 실행문을 통해 다운캐스팅을 하더라도 오류 발생 x
    if(animal4 instanceof Dog) {    
        Dog dog4 = (Dog) animal4;
        dog4.makeSound();
        dog4.fetch();
    }
    
    // animal3는 검증 후에 다운 캐스팅 시도
    // 위의 다운 캐스팅 과정에서 오류가 났었기 때문에 (animal3 instanceof Dog) 조건식의 값은 false
    // 따라서 다운 캐스팅이 일어나지 않고 else 구문이 실행됨.
    if(animal3 instanceof Dog) {
        Dog dog3 = (Dog) animal3;
        dog3.makeSound();
        dog3.fetch();
    } else{
        System.out.println("불가능한 다운캐스팅입니다.");
    } 
  }
}
```

## git clone 하는 법
github 들어가서 리포지토리 -> 초록색 코드버튼 -> 다운로드 ZIP
-> 압축 풀기 -> 폴더에 옮김 -> intellij 에서 열 때 src 있는 부분에서 열기

window +e -> 숨김파일 확인

alt + F12

git init

git config user.name "닉네임"          
git config user.email "이메일"

git config user.name

git config user.email

여태까지는 새로운 깃허브리지토리에 올리는 방법만 함

git remote add origin 리포지토리 주소

git add .
git commit -m "메세지"
git push -u origin main

실패했을 경우
git push -u origin main --force