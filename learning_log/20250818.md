# 예외 (Exception)
- 예외(Exception)란? : 개발자가 예측할 수 있고, 그에 대한 대비를 할 수 있는 것들
- 오류(Error)란? : 개발자가 예측할 수 있지만 해결할 수 없거나 / 예측 불가능한 것

- 다수의 예외의 경우에는 이미 개발자들이 정의를 해놓았습니다.
- 예외 처리를 하는 이유 : 프로그램이 정상 종료 됨을 보증하기 위하여.
- catch 문이 복수로 사용될 수 있음 -> 순서가 중요
#### - IDE 상에서 예외처리가 아니라 빨갛게 나오는 예시
```java
class Person {
    int age;
    String name;

    void showInfo() {
        System.out.println("나이 : " + age);
        System.out.println("이름 : " + name);
    }
}
public static void main(String[] args) {
    Person person1 = new Person();
    person1.name = "김일";
    person1.age = 20;
    // person1.school = "코리아아이티";    // 예시 # 1
    person1.showInfo();
    // person1.displayInfo();            // 예시 # 2
}
```

### - 예외 처리 예시
```java
public static void main(String[] args) {
    
    // 고전적 형태의 예외 처리 방식 -> if문 사용
    Scanner scanner = new Scanner(System.in);
    int a = scanner.nextInt();
    int b = scanner.nextInt();
    if (b == 0) {
        System.out.println("나눌 수 없습니다.");
    } else {
        System.out.println("결과값은 : " + (a + b));
    }
    
    // 예외 처리를 적용한 방식 -> try / catch / finally
    int a = 10;
    int b = 0;
    try {
        int result = a / b;     // ArithmeticException 예외 발생 지점 -> 41번 라인이 아니라 catch 문으로 넘어감
        System.out.println("결과 : " + result);
    } catch (ArithmeticException e) {
        System.out.println("0으로 나눌 수 없습니다. : " + e.getMessage());
    } finally {
        System.out.println("프로그램 정상 종료");
    }
    
    // 배열 인덱스 예외 -> 복수 catch문 사용
    int[] numbers = { 1, 2, 3 };
    try {
        System.out.println(numbers[5]);
    } catch (ArrayIndexOutOfBoundsException e) {
        System.out.println(e.getMessage());
    } catch (Exception e) {  // 예외 중에 가장 상위 예외 클래스에 해당함.
        throw new RuntimeException(e);      
    } finally {
        System.out.println("프로그램 정상 종료");
    }
}
```

### - 로그인 실패 예외 처리 예시
```java
class LoginFailedException extends Exception {
    // 매개 변수 생성자를 사용함.
    public LoginFailedException(String message) {
        super(message);         // 슈퍼(부모) 클래스의 생성자 호출
        System.out.println("예외가 발생했습니다.");
    }
}
public class Exception02 {
    public static void login(String id, String password) throws LoginFailedException {
        // 메서드 내에 지역변수 선언 및 초기화
        String correctId = "admin";
        String correctPassword = "1q2w3e4r";

        // 매개변수와 지역변수의 일치 여부 확인하는 조건문
        // 매서드 내에 고전적인 예외 처리를 작성한 예시
        if (!id.equals(correctId) || !password.equals(correctPassword)) {
//            System.out.println("아이디 혹은 비밀번호를 확인하세요.");
            throw new LoginFailedException(("ID 또는 PW가 틀렸습니다."));   // "ID 또는 PW가 틀렸습니다."를 argument로 하는
            // LoginFailedException 객체가 생성되었다고 할 수 있겠네요.
        }
    }

    public static void main(String[] args) {
        String inputId = "admin";
        String inputPassword = "1234qwer";

//        login(inputId, inputPassword);    // throws 키워드를 달게 되니까오류가 발생
        try {
            login(inputId, inputPassword);
        } catch (LoginFailedException e) {    

            System.out.println("로그인 실패 : " + e.getMessage());
        } finally {
            System.out.println("프로그램 정상 종료");
        }
    }
}
```

### - 범위에 맞지 않는 나이 입력 시 예외 처리 예시
```java
//extends Exception을 통해 예외 관련 클래스임을 명시
public class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {     // 사용자 정의 생성자 정의
        super(message);
    }
}

public static void checkAge(int age) throws InvalidAgeException {
    if(age < 0 || age > 200) {
        // 조건에 맞지 않는 경우 사용자 정의 예외 발생시킬 것
        // 예외를 발생시킨다의 의미 -> 예외 객체를 생성한다는 의미입니다.
        throw  new InvalidAgeException("나이는 0 ~ 200 사이의 정수만 가능합니다.");
    }
}

public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    System.out.print("나이를 입력하세요 >>> ");
    try {                               // 예외가 발생할 가능성이 있는 부분을 try문 안에 넣어줌
        int age = scanner.nextInt();
        checkAge(age);  // 예외를 던질(throw)가능성이 있는 메서드 호출
        System.out.println("입력된 나이는 " + age + "살입니다.");
    } catch (InvalidAgeException e) {
        System.out.println("나이 입력 오류 : " + e.getMessage());
    } catch (InputMismatchException e) {    // Scanner 사용했는데 변수의 자료형과 일치하지 않을 때 적용
        System.out.println("잘못된 입력입니다. 정수를 입력하세요.");
    } finally {
        System.out.println("프로그램 정상 종료");
    }
}
```

---

# Lambda Expression(람다식)
- Java 8에서 도입된 함수형 프로그래밍을 지원하기 위한 표현식

형식 : (매개변수) -> { 실행문 }

```java
// 기존의 익명 클래스 방식
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("Hello, Java");
        }
    };
    runnable.run(); // Hello, Java 출력됨

}

```

이상의 익명 클래스 방식은 저희가 잠깐 다룬 적이 있는데,
Interface Runnable을 활용하여 임시적으로 run() 추상 메서드를 재정의하여 원하는 출력 결과를 도출하는 형태였습니다.
근데 너무 길죠.

```java
// 람다식 적용 방식
public static void main(String[] args) {
    Runnable runnable = () -> System.out.println("Hello, Java");
    
    runnable.run();
}
```
람다식을 적용하면 이상의 코드가 끝입니다.

## 람다식의 등장 배경
- 람다식이 나오기 전에는 Java 에서 함수형 프로그래밍을 하기 위해 익명 클래스를 주로 사용(첫번째 코드 블럭 예시입니다.)
- 하지만 이상의 방식은 예제에서 볼 수 있듯이 코드가 길어지고, 불필요한 반복이 많가지며,
  가독성이 떨어지는 문제가 있었습니다.(call1() 유형의 코드를 5개 정의한다고 하면 runnable1, ...runnable5까지 객체명도 다 다르게 정해야겠죠.)

```java
import java.util.Comparator;

public static void main(String[] args) {
    Comparator<Integer> comparator = new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1.compareTo(o2);
        }
    };  // Comparator 인터페이스의 객체를 임의적으로 사용한 익명 클래스 예시
    
    Comparator<Integer> lambdaComparator = (o1, o2) -> o1.compareTo(o2);
}
```

## 람다식 장점
1. 코드 간결화 - 불필요한 코드 제거로(Integer 반복이 없죠), 가독성 향상
2. 표현력 향상 - 익명 클래스를 짧은 표현으로 대체
3. 지연 연산 - Stream API와 함꼐 사용시 지연 연산을 통해 성능 최적화

## 람다식 단점
1. 디버깅 어려움 - 람다식 내부에서 발생하는 오류의 디버깅이 어렵다.
2. 재사용성 낮음 - 익명 클래스에 '비해' 재사용이 어려움.
3. 복잡한 로직 표현에 부적합 - 단순 로직의 경우 람다식 사용, 아닌 경우는 익명 클래스 사용

## 람다식 문법
람다식 구조는 크데 3가지로 나뉩니다.
1. 매개변수 목록
2. 화살표(->) : 그래서 Js 에서는 arrow expression 이라고 표현합니다.
3. 구현부 / 실행문(한국어판 intellij 에서는 메서드 본문)

```java
public static void main(String[] args) {
    // 1. 매개변수와 실행문이 하나일 때 (중괄호 생략 가능)
    (int x , int y) -> x + y    // return이 생략되어 있습니다. call4()유형
    
    // 2. 매개변수가 하나일 때 (소괄호 생략 가능)
    str -> System.out.println(str); // call2()유형이죠.
    
    // 3. 실행문이 여러 줄일 때 ( 중괄호 필수 )
    (x, y) -> {
        // 지역변수 선언
        int sum = x + y;
        return sum;
    }
}
```

## 함수형 인터페이스(Functional Interface)
- 람다식은 단일 메서드만 가지는 인터페이스(얘를 함수형 인터페이스라고 합니다.)를 구현하는 형태로 사용됩니다.
  `@FunctionalInterface` 어노테이션을 사용하면 컴파일 시에 단일 메서드인지 체크합니다.
- 그래서 '사용자 정의 함수형 인터페이스'를 작성할 때 클래스 레벨에 `@FunctionalInterface`를 명시해줍니다.

이유를 명확하게 알 필요가 있습니다.
인터페이스에 있는 메서드는 전부 '추상 메서드'입니다. -> 얘를 implement 받게 되면 추상 메서드들을 전부 다 '강제로 구현'해야만 합니다.

하지만 아까 말한 것처럼 call1() ~ call4()까지의 유형을 하나의 객체에 강제 구현하게 될 경우
call3()만 필요한데 나머지도 정의해야한다는 문제점이 발생하기 때문에 각 유형 당 하나의 인터페이스/추상메서드만 존재하게 됐습니다.

```java
@FunctionalInterface    // 메서드 하나 초과이면 오류 발생합니다.
interface MyFunction {
    void start();   // 인터페이스 정의했고, 추상메서드가 하나 있습니다.
}

public static void main(String[] args) {
    MyFunction myFunction = () -> System.out.println("정의한 함수를 실행합니다.");
    // 매개변수가 아예 없는 경우는 () 로 표시합니다. 매개변수가 하나면 소괄호 생략이었습니다.
    
    myFunction.start();
}
```

### - 예시
```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}

// 정적 메서드 정의
public static int operate(int a, int b, Calculator c) {
    return c.calculate(a,b);
}

public static void main(String[] args) {
    Calculator add = (x, y) -> x + y;   // Calculator 인터페이스의 객체명이 add 고, 내부 메서드는 calculate()
    Calculator sub = (x, y) -> x - y;   
    Calculator mul = (x, y) -> x * y;
    Calculator div = (x, y) -> x / y;

    System.out.println(add.calculate(2,3));     // 위의 주석을 참고했을 때의 올바른 메서드 호출 방식
    System.out.println(sub.calculate(2,3));     
    System.out.println("--- static method 호출 방식 결과 ---");
    System.out.println("2 + 3 = " + operate(2, 3, add));
    System.out.println("2 * 3 = " + operate(2, 3, mul));
}
```

## Java 에서 제공하는 주요 '함수형 인터페이스'
1. Runnable - void run(); - call()
2. Consumer - void accept(T t);  - call2()
3. Supplier - T get(); - call3()
4. Function<T, R> - R apply(T t); - call4()
5. Predicate - boolean test(T t); - 얘는 return 타입이 boolean 으로 고정이라 call1~ call4로 묶기 애매하긴 한데 
   굳이 따지자면 call4()입니다. return true / false 중 하나니까요.

### 함수형 인터페이스 별 상세
1. Runnable
    - 매개변수도 없고, 반환값도 없는 단순 실행을 위한 인터페이스
    - 사용처 : 스레드 실행 시, 비동기 작업 실행 시
2. Supplier
    - 매개변수 없이 값을 반환하는 인터페이스, 단순히 값을 '공급'하는 역할
    - 사용처 : 객체 생성, 지연 로딩
3. Consumer
    - 값을 매개변수로 받아서 사용하고, 아무 것도 반환하지 않는 인터페이스, 데이터를 '소비'하는 역할
    - 사용처 : 데이터 처리, 로깅, 이벤트 핸들러
4. Function<T, R>
   - '하나의 매개변수'를 받아서, 연산을 수행한 후 결과를 리턴함.
     - T는 입력 타입, R은 리턴 타입을 명시함/
   - 사용처 : 데이터 변환, 매핑 처리, 컬렉션 조작
5. Predicate
   - '하나의 매개변수'를 받아서 특정 조건을 검사한 뒤 true / false 를 반환
   - 사용처 : 필터링, 조건 검사, 유효성 검사
     - 특히 Predicate의 경우 true / false 반환값을 가지고 조건문을 돌릴 때 많이 사용됩니다.
6. 함수형 인터페이스 조합
    - Java 8 에서는 함수형 인터페이스끼리의 조합이 가능합니다.
```java
import java.util.function.Predicate;

public static void main(String[] args) {
    // 메서드 1
    Predicate<String> startsWithA = str -> str.startsWith("A"); // .startsWith()는 String 클래스에 있는 메서드
    // 메서드 2
    Predicate<String> endsWithX = str -> str.endsWith("X");
    
    // and()로 두 조건 결합
    Predicate<String> startsWithAAndEndsWithX = startsWithA.and(endsWithX);

    System.out.println(startsWithAAndEndsWithX.test("Alex"));
}
```

```java
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("Hello, Java");
        }
    };      // 객체 정의이기 때문에 ; 필수

    runnable.run(); // 이상의 방법은 메서드명이 명시됨

    Runnable lambdaRunnable = () -> System.out.println("Hello, Lambda");
    lambdaRunnable.run();   // 메서드명이 없음

    // 다른 유형의 함수형 인터페이스 실행 예제
    // 2. Supplier -> call3();
    Supplier<String> stringSupplier = () -> "Hello, Supplier";
    System.out.println(stringSupplier.get());
    String message = stringSupplier.get();
    System.out.println(message);
    
    // 3. Consumer -> call2();
    Consumer<String> stringConsumer = (memo) -> System.out.println("메시지 : " + memo);
    stringConsumer.accept("오늘 전반적인 수업 내용은 여기서 끝납니다.");
}
```

### - ForEach 메서드 내 람다식 적용 예시
```java
public static void main(String[] args) {
    // List 생성 -> 선언 및 초기화 
    List<String> fruits = Arrays.asList("사과", "딸기", "블루베리");

    System.out.println(fruits);
    
    // 1. 일반 for 문
    for (int i = 0; i <fruits.size(); i++) {
        System.out.println("과일명 : " + fruits.get(i));
    }
    System.out.println();
    // 2. 향상된 for 문
    for ( String fruit : fruits) {
        System.out.println("과일명 : " + fruit);
    }
    System.out.println();
    // 3. 람다식 적용한 method forEach
    fruits.forEach(fruit -> System.out.println("과일명 : " + fruit));

    List<Integer> numbers = Arrays.asList(1,2,3,4,5);
    numbers.forEach(number -> System.out.print((number * 2) + " "));
}
```

# 시험 관련 안내
09:00에 안낸 시작 -> 09:10 ~ 17:50
객체지향 프로그래밍 언어
1. 프로그래밍 언어 활용
2. 프로그래밍 언어 응용

## 프로그래밍 언어 활용
20문제 서답형

.md 파일 상에서 명시적으로 정리되지 않은 부분이 있습니다.
구글에서 검색하는 것 가능.
Github, 자체 코드 정리한 거 노트 확인 등 전부 가능합니다.
ctrl + shift + f 누르면 파일 전체에서 검색이 가능합니다.

- 특정 문제가 md 파일에 없다는 것을 확신하신다면 구글에서 검색해서 알아봐야 할 때가 있을겁니다.

특정 메서드 이름을 적으시오.
특정 자료형을 적으시오.
키워드를 적으시오. 등등...

예비 선발 문제에서도 한 문제는 있습니다.
예외는 물어볼겁니다.

## 프로그래밍 언어 응용 - 각 20점씩
JSON        - 20
Singleton   - 20
Builder     - 30
Collection  - 30

저장만 누르면 안되고 제출까지 해야함.
근데 지출하면 수정이 안됨.
60점 미만은 재시험 대상자
1과목 / 2과목