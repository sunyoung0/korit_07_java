# 금일 수업 계획
1. 상속 관련 예제 복습
2. 추상 클래스 / 추상 메서드
3. 인터페이스
4. casting

---

### - 상속 관련 예제 복습 Book / EBook / BookMain 클래스 활용
- 오버라이딩 하지 않고 자식 클래스의 고유 메서드로 별개로 만든 경우 (이름이 부모 클래스의 메서드와 겹쳐도 관계 x)
```java
public class Book { // 부모 클래스
    private String title;
    private String author;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }
    
    public String getTitle() {
        return title;
    }
    public String getAuthor() {
        return author;
    }
    
    public void showInfo() {
        System.out.println("제목 : " + this.title + "\n저자 : " + this.author);
    }
}

public class EBook extends Book {   // 자식 클래스
    private  double fileSize;
    private String format;

    public EBook(String title, String author, double fileSize, String format) {
        super(title, author);
        this.fileSize = fileSize;
        this.format = format;
    }
    public String getFormat() {
        return format;
    }
    public void setFormat(String format) {
        this.format = format;
    }

    @Override
    public void showInfo() {
        super.showInfo();
        System.out.println("파일 크기: " + this.fileSize + "MB \n파일 형식 : " + this.format);
    }
}

public static void main(String[] args) {
    Book book1 = new Book("자바의 정석", "남궁성");
    System.out.println("이 책의 제목은 " + book1.getTitle() + "입니다.");
    book1.showInfo();
  
    EBook eBook1 = new EBook("스프링 입문", "이강준", 5.2, "EPUB");
    eBook1.setFormat("PDF");
    System.out.println("이 전자책의 포맷은 " + eBook1.getFormat() + "입니다.");
    eBook1.showInfo();
}
```

---

# intellij 에서의 .md 파일 에서의 자동 줄바꿈 설정
1. ctrl + alt + s 누른다 -> 설정
2. 설정 에디터 / Editor -> 일반

---

# 추상 클래스 (Abstract Class)
- abstract - 추상적인

## 추상 클래스의 정의
1. 추상 메서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의돼야 함.
2. 추상 클래스는 객체를 생성할 수 없음 -> 일반 클래스와의 차이
3. 그 외의 다른 특징은 일반 클래스와 동일함
4. 상속을 전제로 하는 클래스

- 추상 메서드(abstract method) - 선언만 있고, 구현은 없는 메서드
- 추상 클래스(abstract class) - 추상 메서드가 '하나 이상인' 클래스


- 일반 메서드 VS 추상 메서드 구조 차이({} 영역의 유무)
```java
// 일반 메서드
public void showInfo() {
    System.out.println("제 이름은 " + name + "입니다.");
}    
// 추상 메서드
public abstract showName();
```

## 추상 클래스의 장점
코드의 재사용성을 높이고 설계를 보다 명확하게 할 수 있도록 도와준다.

## 추상 클래스의 목적
1. 공통된 기능 제공 : 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의 가능
2. 구체적인 구현 _강제_ : 추상 메서드를 통해 자식 클래스가 '반드시 특정 메서드를' 구현하도록 강제할 수 있음.
3. 코드의 재사용성 : 중복되는 코드를 줄이고, 유지보수성을 향상.

## 주의 사항
객체 생성 못함

### - 추상 클래스 예시
추상 클래스는 객체 생성을 '원래는' 못함
;를 꼭 명시해야하는데 전체 코드라인이 메서드를 정의하는 것이 아니라 객체를 생성한 것이기 때문
이상의 개념은 익명 클래스로, 재사용하지 않고 한 번만, 즉 이 경우에는 FactoryMain 에서만 쓰고 치울 예정이면 사용하기 좋음
```java
public abstract class Factory {
  private String name;

  public abstract void produce(String model);
  public abstract void manage();

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }
  public void showInfo() { System.out.println("공장의 정보를 출력합니다.\n공장 이름 : " + name); }
}

public class PhoneFactory extends Factory {
    @Override
    public void produce(String model) { System.out.println("[" + model + "] 모델 스마트폰을 생산합니다."); }
    @Override
    public void manage() { System.out.println("스마트폰 공장을 관리합니다."); }
}
```
```java
public class FactoryMain {
  public static void main(String[] args) {
    Factory factory1 = new Factory() {
      @Override
      public void produce(String model) { System.out.println(this.getName() + "에서 [" + model + "]을 생산합니다."); }
      @Override
      public void manage() { System.out.println("가전 제품 공장을 관리합니다."); }
    };  

    factory1.setName("가전 제품 공장");
    factory1.showInfo();

    PhoneFactory phoneFactory1 = new PhoneFactory();
    phoneFactory1.setName("애플 스마트폰 공장");
    phoneFactory1.produce("아이폰17에어");
    phoneFactory1.manage();
    phoneFactory1.showInfo();
  }
}
```

---

# 인터페이스(Interface)
- Java 에서 클래스가 구현해야하는 '메서드들'의 집합을 정의하는 일종의 규약(protocol)
- 인터페이스는 메서드의 시그니처(메서드명, 리턴타입, 매개변수 목록)만을 포함하며,
  메서드의 실제 구현은 포함하지 않음 -> 추상 메서드만 있음
- 다중 상속을 지원 -> 이를 통해 클래스가 여러 인터페이스를 구현할 수 있음
  - 추상 클래스는 단일 상속을 지원해서 상속 과정을 알아보기 쉽다고 작성했는데,
  - 얘는 다중상속을 지원하기 때문에 또 편하다고 이야기를 합니다.

## 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드들은 기본적으로 추상 메서드
   - 추상 클래스는 일반 메서드도 있었지만, 인터페이스는 강제적으로 추상 메서드 입니다.
2. 상수 : 인터페이스 내에서 선언된 변수는 모두 자동으로 'public static final' 상수로 취급됩니다.
3. 다중 상속 : 클래스는 여러 인터페이스를 구현(implements)할 수 있음.

## 추상 클래스와의 공통점
- 모두 추상 메서드를 포함할 수 있고, 이를 서브 클래스에서 구현해야만 함.

## 추상 클래스와의 차이점
- 추상 클래스
    1. 부분 구현 허용 : 추상 클래스는 추상 메서드 뿐만 아니라 일반 메서드도 포함할 수 있다.
    2. 상태 저장 가능 : 추상 클래스는 field를 가질 수 있다.
    3. 단일 상속 : (일반) 클래스는 하나의 추상 클래스만 상속받을 수 있다.
    4. 생성자 : 추상 클래스는 생성자를 가질 수 있다.

```java
// 어떤 추상 클래스
public abstract class Person {
    // 필드 선언
    private String name;
    // AllArgsConstructor
    public Person(String name) {
        this.name = name;
    }
    // method 구현
    public abstract introduce();
}

// 위의 추상 클래스를 상속 받는 일반 클래스
public class Student extends Person {
    // 서브 클래스의 필드 선언
    private String school;
    // 추상 클래스가 AllArgsConstructor 생성자만 가지고 있기 때문에
    // Student 클래스가 객체를 생성할 수 있는 경우의 수는 이렇게 두가지만 존재하게 됩니다.
    public Student(String name) {
        super(name);
    }
    
    public Student(String name, String school) {
        super(name);
        this.school = school;
    }
}
```

이상의 코드라인으로 알 수 있는 것은, 객체 생성을 직접적으로 하지 못하는 추상 클래스의 생성자의 유무로 인해 자식 클래스의 생성자 정의 방식(객체 생성 방식)을 통제할 수 있다는 점입니다.

그래서 특정 서브 클래스의 객체 생성 방식을 강제하고 싶을 때 사용하는 것이 추상 클래스의 생성자라고 생각하시면 되겠습니다.

5. 다양한 접근 지정자(Access Modifier) : 추상 클래스의 메서드와 변수는 다양한 접근 지정자를 가질 수 있다.
- 인터페이스
    1. 완전한 추상화 : 인터페이스는 기본적으로 모든 메서드가 추상 메서드 (Java8이후에 default / static 메서드를 사용가능하긴 합니다.)
    2. 인터페이스는 인스턴스 변수(필드 중 객체마다 값이 다른 변수를 의미함)를 가질 수 없고, 상수만 선언 가능(final 키워드)
    3. 다중 상속 : 클래스는 여러 인터페이스를 '구현할 수 있다.' (상속과 용어를 구분 짓는 편)
    4. 생성자 없음 : 인터페이스는 생성자를 가질 수 없다.
        - 일단 필드에서 객체마다 다른 값을 지닐 수 없고 상수만 선언 가능하기 때문에 필드에 값을 대입하는 생성자 자체를 만들 수 없겠죠.
    5. 자동 public : 인터페이스의 메서드들은 자동으로 public 이며, 메서드 선언에 접근 지정자를 명시할 필요 x (근데 또 Java8 이후에 default / static 메서드가 생긴점이 문제긴 합니다.)

인터페이스 사용하는 이유 : 구현을 강제하기 위해서 작성, 동일한 메서드 명을 가졌음을 개발자들이 확신하기 위해

밑의 예시에서 button 클래스는 객체 생성을 못하기 때문에 Button을 상속받은 클래스들에서 구현을 해줌
### - 인터페이스 예시
- 티비 리모컨 기능 구현 예시 button 클래스에 interface를 implement함.
```java
public interface Press { void onPressed(); }
public interface Up { String onUP(); }
public interface Down { void onDown(); }

public abstract class Button implements Press, Up, Down { 
    @Override
    public void onDown() { }
    @Override
    public abstract void onPressed();
    @Override
    public String onUP() { return "올립니다."; }
}

public class ChannelUpButton extends Button {
    @Override
    public void onPressed() { System.out.println("채널을 한 칸 올립니다."); }
    @Override
    public String onUP() { return "채널을 계속 " + super.onUP(); }
}

public class ChannelDownButton extends Button {
    @Override
    public void onPressed() { System.out.println("채널을 한칸 내립니다."); }
    @Override
    public void onDown() { System.out.println("채널을 계속 내립니다."); }
}
```

위의 클래스들을 하나로 모아주는 TvRemoteController 클래스
  - 직접 지정한 클래스가 필드,객체가 됨   ->  접근지정자 클래스명 객체명
```java
public class TvRemoteController {
    private PowerButton powerButton;        
    private ChannelDownButton channelDownButton;
    private ChannelUpButton channelUpButton;

    public TvRemoteController(PowerButton powerButton, ChannelDownButton channelDownButton, ChannelUpButton channelUpButton) {
        this.powerButton = powerButton;
        this.channelDownButton = channelDownButton;
        this.channelUpButton = channelUpButton;
    }

    // 선언한 필드(객체)의 메서드를 호출
    public void onPressedPowerButton() { powerButton.onPressed(); }
    public void onPressedChannelDownButton() { channelDownButton.onPressed(); }
    public void onDownChannelDownButton() { channelDownButton.onDown(); }
    public void onPressedChannelUpButton() { channelUpButton.onPressed(); }

    // void가 아니라 String 으로 타입을 지정했기 때문에 풀이법이 두 가지
    // # 1
    public String onUpChannelUpButton1() {
        return channelUpButton.onUP();      
        // onUp();의 결과값이 return "채널을 계속 " + super.onUp();
    }
    // # 2
    public void onUpChannelUpButton2() { System.out.println(channelUpButton.onUP()); }
}
```
- main 클래스
```java
public class Main {
  public static void main(String[] args) {
      // 별개의 버튼 객체들을 만들지 않고 TvRemoteController 객체생성 -> 각각 객체는 있지만 객체명은 없음
      TvRemoteController tvRemoteController = new TvRemoteController(
              new PowerButton(), new ChannelDownButton(), new ChannelUpButton()); 
      
      tvRemoteController.onPressedPowerButton();
      tvRemoteController.onPressedChannelDownButton();
      tvRemoteController.onDownChannelDownButton();
      tvRemoteController.onPressedChannelUpButton();
      // # 1 에 대한 Main 에서의 실행 방법
      System.out.println(tvRemoteController.onUpChannelUpButton1());
      // # 2 에 대한 Main 에서의 실행 방법
      tvRemoteController.onUpChannelUpButton2();
  }
}
```