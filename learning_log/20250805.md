# 금일 수업 계획
1. 배열 (Array)

# 접근 지정자 추가 설명
## public -> 모든 곳에서 접근이 가능
    1. 완전히 공개된 상태
    2. 누구든지 사용 가능
    3. 보통 라이브러리나 API의 공개된 기능에 사용됨
```java
public class Car{
    // 필드 선언 및 초기화
    public String model = "셀토스";
    
    // 메서드 정의
    public void drive() {
        System.out.println("자동차를 운전합니다.");
    }
}
```
이상의 코드는 다른 어떤 클래스를 생성하더라도 경로만 정확하다면 Car car1 = new Car();로
객체를 생성할 수 있고 (class가 아닌 public 이니까), System.out.println(car1.model);이라고 했을 때
'셀토스'라는 String 데이터가 콘솔에 찍힐겁니다.(field가 public 이니까) 마지막으로 car1.drive();를
호출해도 콘솔에 "자동차를 운전합니다"라는 텍스트가 콘솔에 나올겁니다.(method가 public 이니까)

## private -> 자기 클래스 내부에서만 접근 가능
1. 가장 제한적인 접근 지정자
2. 클래스 외부에서는 전혀 접근할 수 없음
3. 데이터 보호 목적으로 사용
```java
public class Car {
    private String engine = "V6";
    
    public void showEngine() {
        System.out.println("엔진 정보 : " + engine);
    }
    
} 

// 별개의 클래스
public  class CarMain {
    public static void main(String[] args) {
        // 객체 생성
        Car car1 = new Car();
        System.out.println(car1.engine);    // 컴파일링 오류 : 필드 자체는 private
        car1.showEngine();  // 엔진 정보 : V6 라고 출력됨 ->  method는 public 이기 때문에
    }
}
```
Car를 시준으로는 field는 private / 일부 정보만 공개하게 되는 method는 public 이기 때문에
CarMain 에서 객체를 생성하는 것 가능(class level - public) /
엔진 정보를 직접 조회하는 것(car1.engine)은 불가능 field는 private 이니까
하지만 method를 경유하여 조회하는 것은 가능(car1.showEngine()) - method는 public 이니까

## protected -> 같은 패키지 클래스 + 상속(추후 수업)관계에서 접근 가능
기본적으로 추후에 배울 default와 같지만 자식 클래스에서 상속 받아서 사용 가능
```java
package vehicle;

public class Car {
    protected String brand = "기아";
}

// 같은 패키지의 다른 클래스
pakage vehicle;

import vehicle.Car;

public class MyCar extends Car {   // extends는 상속 관계를 나타내는 키워드
    public void showBrand() {
        System.out.println(brand);
    }
}


```
추후 상속 개념을 학습했을 때 더 자세히 알 수 있지만 Car 클래스의 protected 필드인
brand를 동일한 패키지의 MyCar 클래스에서 '직접 조회'했습니다.(Getter와 같은 메서드를 경유한 것이 아니라)

## (default) -> 아무 접근 지정자도 없을 때 (package-private)
1. 같은 패키지 안에서는 접근 가능, 다른 패키지에서는 불가능
```java
class Car {
    String color = "red";
} 
```
이상의 경우, class 레벨도 default / field 레벨도 default 라고 볼 수 있습니다.
그리고 저희는 여태까지 챕터 단위로 패키지를 만들었고 그 안에서 객체 생성을 했었기 때문에
ch08_methods 이후로 별 문제 없이 패키지 내에서 클래스를 만들고
(Car / CarMain 을 만들고), 객체를 생성하고, 필드도 조회하고, 메서드도 호출 가능 했었습니다.

앞으로의 수업부터는 접근 지정자를 분명하게 명시하여 개발자인 여러분들이 직접 통제하도록 진행될 예정입니다.

## 실무적인 관점에서의 접근 지정자 선택
1. 필드는 원칙적으로 -> private
2. 메서드는 외부 공개 필요시 -> public
3. 상속 대상 메서드는 -> protected
4. 패키지 내부에서만 쓰이는 도우미 클래스 -> (default)

### 항상 그런 것은 아니지만 염두해두면 좋은 부분
1. 필드는 웬만하면 private 으로 지정하고, 접근은 getter / setter 를 통하자 (자동완성이 public 인 이유)
2. 인터페이스나 라이브러리는 public을 최소화할 것. 이미 공개된 API는 되돌리기 어려움
   - 다른 회사가 내가 만든 class를 쓰고 있는데 멀쩡하게 public 으로 되어있던게 default로 바뀌게 되면
     그 회사는 더 이상 제가 만든 class를 사용하지 못하게 될거고, 기존 로직을 다 갈아엎어야 할겁니다.

---

## 전체 복습
Character / CharacterMain 클래스 생성
접근 지정자 / getter / setter / 메서드 / 생성자
```java
class Character {
    // 필드 선언 - 접근지정자
    public String name;     // 공개가능
    private int health;     // 읽기만 허용
    int power;              // 같은 패키지만
    protected String skill; // 자식 클래스만

    // 생성자 (캐릭터 생성시에 필수적으로 요구되는 애들만 매개변수로 받은 매개변수 생성자)
    public Character(String name, String skill, int power) {
        this.name = name;
        this.skill = skill;
        this.power = power;

        this.health = 100;      // 초기 체력(매개변수가 없음 객체 생성시에 무조건 체력 100으로 고정)
    }

    // getter / setter
    public void setName(String name) { this.name = name; }
    public void setHealth(int health) { this.health = health; }
    public void setPower(int power) { this.power = power; }
    public void setSkill(String skill) { this.skill = skill; }
    
    public String getName() { return name; }
    public int getHealth() { return health; }
    public int getPower() { return power; }
    public String getSkill() { return skill; }
    
    // 메서드
    public void attack() {
        System.out.println(name + "이(가) " + power + "의 힘으로  공격합니다 !");
    }
    public void heal() {
        health += 10;
        System.out.println(name + "의 체력이 회복되었습니다. 현재 체력 : " + health);
    }
}

public class CharacterMain {

    public static void main(String[] args) {

        Character warrior = new Character("전사", "세로베기", 200);
        
        warrior.attack();
        warrior.heal();
    }
}
```

---

# 배열 (Array)
## 배열의 필요성
여태까지의 수업을  기준으로 하면 10개의 정수형 데이터를 저장하려면 int 변수를 10개 선언해서 저장해야합니다.
배열은 '같은' 자료형의 데이터를 하나의 변수에 저장해서 관리하는 방식입니다. -> Java 에서입니다.
즉 110번 라인과 같은 상황에서 하나의 변수만 가지로 내부에 10개의 int 데이터를 저장할 수 있음을 뜻합니다.

## 선언 방식
자료형[] 변수명
```java
형식 :
    자료형[] 변수명 = 데이터;
    int[] arr01 = {1, 2, 3, 4, 5};  // 그럼 얘는 변수 선언 및 초기화에 해당하겠네요.

```

### 배열 내용 정리
```java
public static void main(String[] args) {
    // 배열 선언 및 초기화
    int[] arr01 = { 1, 2, 3, 4, 5 };
    
    System.out.println(arr01);  // 결과값 : [I@36baf30c    - 주소지가 출력

    System.out.println(arr01[0]);   // 배열명[index]의 형태로 내부 데이터를 직접 확인 가능
    System.out.println(arr01[1]);
    
    // 반복문을 활용하여 arr01의 내부 element 들을 출력
    for(int i = 0; i < 5; i++) {              
        System.out.print(arr01[i] + " ");       
    }

    for(int i = 0 ; i < arr01.length; i++) {    // arr01.length 형태로 배열 내부의 데이터 개수가 바뀌더라도 문제 없음
        System.out.print(arr01[i] + " / ");
    }

    // 필드를 참조할 때 객체명.필드 형태 arr01.length
    // 그리고 field를 직접 참조 했으므로 length 필드는 public
    // 배열은 객체라고 할 순 없지만 field로 length를 가진다.

    // 빈 배열 생성
    int[] arr02 = new int[10];

    // 배열 내부 데이터의 개수 / 주소지의 한계값 -1 을 항상 아는것이 아니기 때문에
    // element 값을 출력하기 위한 반복문의 한계값을 설정할 때 배열명.length로 표현

    arr01[0] = 10;      // 재대입
    System.out.println(arr01[0]);   // 결과값 : 10

    // 배열에 값을 대입할 수가 있음
    // 빈 배열 arr02에 값을 대입하기
    for ( int i = 0 ; i < arr02.length ; i++) {
        System.out.println(arr02[i]);
    }

    // arr02에 21, 22, ..., 30을 대입하고 21 / 22 / ... / 30 / 형태로 출력
    for ( int i = 0; i < arr02.length ; i++) {
        arr02[i] = 21 + i;      // 값을 대입
        System.out.print(arr02[i] + " / ");
    }

    //다른 자료형의 배열이더라도 기본적으로 element를 추출하는 절차는 동일
    String[] strArray01 = {"안", "녕", "하", "세", "요"};
    System.out.println(strArray01[0]);
}
```

### - 점수를 입력해서 배열에 저장하고 총 합을 구하는 예시
```java
import java.util.Scanner;

public static void main(String[] args) {
    
    Scanner scanner = new Scanner(System.in);
    int human = 0;
    System.out.print("몇 명의 학생을 입력하시겠습니까? >>> ");
    human = scanner.nextInt();
    
    double[] scores = new double[human];
    double sum = 0;
    
    for (int i = 0; i < scores.length; i++) {    //humans.length나 scores.length나 human 이나 다 같죠.
        System.out.print((i+1) + "번 학생의 점수를 입력하세요 >>> ");
        scores[i] = scanner.nextDouble();
        sum += scores[i];
    }
    System.out.println("\n학생들의 점수의 총합은 " + sum + "점입니다.");
}
```
### - 배열을 입력하고 출력하는 메서드를 만드는 예시
```java
public void printElements() {
String[] names = { "김일", "김이", "김삼", "김사", "김오", "김육" };
    for (int i = 0; i < names.length; i++) {
        System.out.print(names[i] + " ");
    }
}

// 오버로딩
public void printElements(String[] strArray) {
    for (int i = 0; i < strArray.length; i++) {
        System.out.print(strArray[i] + " ");
    }
}

// 입력 관련 메서드 정의
public void writesElements(String[] strArray) {
    // 매개변수로 받은 배열에 값을 입력할 수 있도록 하는 메서드 정의
    Scanner scanner = new Scanner(System.in);

    for (int i = 0; i < strArray.length; i++) {
        System.out.print("값을 입력하세요. >>> ");
        strArray[i] = scanner.next();
    }
}

public static void main(String[] args) {
    // 임의의 String[] 배열 생성
    String[] people = new String[5];

    // 메서드 호출 영역
    Array04 array04 = new Array04();

    array04.writesElements(people);     // 입력하는 메서드
    array04.printElements(people);      // 출력하는 메서드

    array04.printElements();    // 메서드를 호출했을 때 특정 배열의 element만 출력됨
    System.out.println();

    String[] students = { "이일", "이이", "이삼", "이사", "이오" };
    array04.printElements(students);
    System.out.println();
}
```

### - String[ ] scores 배열에 A B C D F element를 입력하고 A+ B+ C+ D+ F 로 출력하는 예시
```java
import java.util.Scanner;

public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    String[] scores = new String[5];

    for (int i = 0; i < scores.length; i++) {
        System.out.print("점수를 입력하세요 >>> ");
        scores[i] = scanner.next();
    }

    // 배열의 마지막 요소인 F에만 +가 붙지 않았기 때문에 scores.length - 1 를 사용해서
    // 마지막 배열 앞까지 출력 후 마지막 배열은 따로 출력해줌
    for(int i = 0; i <(scores.length - 1); i++) {
        System.out.print(scores[i] + "+ ");
    }
    System.out.print(scores[scores.length - 1]);
}
```
### - 총점과 평균을 계산해서 출력하는 예시
```java
public static void main(String[] args) {

    int[] scores = { 100, 90, 80, 70, 60, 50, 40, 30, 20, 10 };

    int sum = 0;
    double avg = 0;

    for(int i = 0; i < scores.length; i++) {
        sum += scores[i];
    }
    avg = ((double) sum / scores.length);

    System.out.println("총점 : " + sum + "점");
    System.out.println("평균 : " + avg + "점");
}
```