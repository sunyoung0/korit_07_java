# 금일 수업 계획
Generic
Collections

---

## JS 에서의 객체 정의 방식
```jsx
const person1 = {
    name : "김일",
    age : 20
};
```
이상의 형태가 python 에서는 dictionary 라는 표현을 쓰고, java 에서는 또 map 이라고 씁니다.
person1.name = "김이";

# 제네릭(Generic)
## 개념 및 정의
클래스나 메서드가 다룰 데이터 타입을 미리 명시하여 재사용성과 유연성을 높이는 기술

### 타입 매개변수(type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 '대신하여 사용하는 매개변수'
- 일반적으로 알파벳 대문자 하나로 표기함.
    1. T(Type) : 일반적으로 클래스 타입을 나타낼 때 사용
    2. E(Element) : 컬렉션(추후수업)의 요소를 나타낼 때 사용
    3. K(Key) : Map(추후 수업)의 Key를 나타낼 때 사용
    4. V(Value) : Map의 Value 또는 제네릭 타입의 리턴값으로 사용
### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할 수 있어 코드 재사용성을 높이고 중복을 줄입니다.

    - 예를 들어 method overloading 개념이 있을 경우, Person 객체를 참조하여
      bmi 를 계산한다고 가정하겠습니다.
```java
package org.example;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class Person {
    private String name;
    private double height;
    private double weight;
}

public void calcBmi(Person person) {
    String name = person.getName();    
    double height = person.getHeight() * 0.01; 
    double weight = person.getWeight(); 
    double bmi = weight / (height * height);    
    
    String result = "";
    if ( bmi <18.5 ) { result = "3단계 비만"; } 
    else if ( bmi < 23 ) { result = "2단계 비만"; } 
    else if ( bmi < 25 ) { result = "1단계 비만."; } 
    else if ( bmi < 30) { result = "비만 전단계"; } 
    else if ( bmi < 35 ) { result = "정상"; } 
    else { result = "저체중"; }
    System.out.println(name + "님의 BMI 지수는 " + bmi + "으로 " + result + "입니다.");
}
```
이상과 같이 쓸 수 있겠습니다. 그렇다면, 만약에 Student 클래스가 Person 클래스를 상속 받았다고 가정할 때,
Student 클래스 용으로 또 method overloading을 해야하는가와 같은 문제가 있습니다.
그리고 Student의 상속을 받는 MiddleSchoolStudent 라든지 HighSchoolStudent가 있으면 더 골치가 아파지겠네요.
* 참고 : 사실은 upcasting이 이루어지기 때문에 별 문제 없습니다.

### 타입 안정성(Type Safety)
- 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고, 명시적인 형변환을 줄임.

# Java 제네릭 와일드 카드(Generic WildCard)

## 제네릭
- 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법으로 다양한 타입에 재사용이 가능.
```java
public class Box<T> {
    // 필드 선언
    private T value;
    public void setValue(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
```

과 같은 방식으로 작성했을 때 value의 자료형을 고정시키지 않고 사용이 가능함.
value 에 String / Integer / Double / Product / Item ... ect 등으로 사용 가능합니다.
즉 Java 자체의 자료형(class) 뿐만 아니라 개발자가 정의한 것도 집어넣을 수 있다는 점에서 재사용성이 높다고 할 수 있습니다.

### - 예시
```java
@AllArgsConstructor
@Data
public class ResponseData<T> {
    private String message;
    private T data;
}

public static void main(String[] args) {
    Date now = new Date();      // Java 내장 클래스로 객체 생성

    ResponseData<String> responseData1 = new ResponseData("날짜 저장 성공", now.toString());
    System.out.println(responseData1);
    ResponseData<Integer> responseData2 = new ResponseData("나이 저장 성공", 38);
    System.out.println(responseData2);
    ResponseData<Date> responseData3 = new ResponseData("날짜 객체 저장 성공", now);
    System.out.println(responseData3);
}
```

## 와일드 카드
- 이상의 제네릭 타입을 사용할 때 구체적인 타입을 명시하지 않고 범용적으로 처리하고 싶을 때 사용함.
`?` 기호를 사용합니다.

```java
import java.util.ArrayList;
import java.util.List;

public static void main(String[] args) {
    List<?> exampleList = new ArrayList<String>();
}
```

`<?>` 은 어떤 타입이든 가능하다는 의미입니다.

### 종류
1. 모든 타입 허용
    - 읽기 전용. 어떤 타입이든지 받아야만 할 때
2. T 또는 T의 서브 타입(자식 클래스) 
    - 읽기 전용. 제한된 타입에서 읽을 때
3. T 또는 T의 슈퍼타입(부모 클래스)
    - 쓰기 전용. 제한된 타입으로 넣을 때

### - 예시
```java
public abstract class Animal {
    public abstract void move();
}

public class Human extends Animal{      // Animal을 상속
    @Override
    public void move() { System.out.println("사람이 두발로 뜁니다."); }
    public void read() {  System.out.println("사람이 책을 읽습니다."); }
}

public class Car {      // Animal을 상속 X
    public void move() { System.out.println("차가 움직입니다."); }
    public void brake() { System.out.println("차가 멈춥니다."); }
}

@AllArgsConstructor
@Data
public class AnimalData<T> {
    private T animal;

    public void showData() {
        ((Animal)animal).move();        

        if ( animal.getClass() == Human.class) {
            ((Human)animal).read(); 
        } else if ( animal.getClass() == Tiger.class) {
            ((Tiger)animal).hunt();
        }
    }
}

public class Main {
    // 필드로 들어온 객체가 Animal 클래스의 서브 클래스인지 아닌지를 구분하는 메서드
    public AnimalData<? extends Animal> getAnimal(int flag) {
        if ( flag == 1 ) {
            AnimalData<Human> animalData = new AnimalData<>(new Human());
            return animalData;
        }
        return null;
    }

    public static void main(String[] args) {

        AnimalData<Human> animalData1 = new AnimalData<>(new Human());
        AnimalData<Car> animalData2 = new AnimalData<>(new Car());

        animalData1.showData();
        animalData2.showData(); // 오류 발생
        
        Main main = new Main();
        AnimalData<? extends Animal> animalData3 = main.getAnimal(1);
        AnimalData<? extends Animal> animalData4 = main.getAnimal(2);
        
        System.out.println("----");
        if (animalData3 != null) {
            animalData4.showData();
        }
        if (animalData4 != null) {
            animalData5.showData();
        }
        else  {   // animalData4 == null 이라면
            System.out.println("아무것도 없습니다.");
        }
    }
}
```
---

# Collection
- 여러 객체를 모아놓은 것들을 의미함 -> 배열과는 좀 차이가 있습니다.
- 다만 Java 에서의 List는 Python 에서의 List 와도 차이가 있습니다.

## 종류
1. List : 순서가 있는 데이터의 집합으로, 중복된 요소를 허락함.
    - ArrayList : 배열 기반의 리스트, 요소(element) 접근 속도가 빠름.
    - LinkedList : 연결 리스트, 삽입 / 삭제 속도가 빠름.
2. Set : 중복을 허용하지 (List 와의 차이 # 1)않는 데이터들의 집합(중1 때 배우는 그 집합입니다.)
    - HashSet : 해시 테이블 기반의 집합, element의 순서를 보장하지 않음.(List 와의 차이 # 2)
    - TreeSet : 이진(binary) 검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨.
3. Map : Key / Value 의 쌍으로 이루어진 데이터들의 집합.
    - HashMap : 해시 테이블 기반의 맵, 키의 순서를 보장 x
    - TreeMap : 이진 검색 트리 기반의 맵, 키가 정렬된 상태로 유지 

* Java 상에서의 Map의 키 (Key)- 값 (Value) 쌍을 지칭하는 용어 : entry
* Js 상에서 객체의 키-값 쌍을 지칭하는 용어 : Property
* 근데 문제는 Python 에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes - Java 상에서의 field

#### List와 Array 차이점
1. 선언 방식 : List의 경우 인덱스 넘버 고정이 없지만, 배열의 경우 인덱스 넘버를 고정해줘야만 함.
2. 값을 대입하는 방법 : List는 메서드를 통해 값을 넣음 순서가 보장되므로 넣은 순서대로 값이 들어감.                     배열은 값을 직접 대입
3. 출력 방식 : 배열 -> Arrays.toString(strArray) List -> sout(리스트명)

#### List 내부 메서드
- 특정 element 검색 -> 리스트명.contains(목적어)
  - List는 element가 명확하게 일치하는지를 확인
  - ex) py가 python의 일부이긴 하지만 전체를 의미하지 않기 때문에 결과 -> false
- 특정 element의 삭제 -> 리스트명.remove(특정 element);
- 정렬 -> Collections.sort(리스트명);
- 역순 정렬 -> Collections.sort(리스트명, Comparator.reverseOrder());
- 정렬할 때 대문자 먼저 그 다음 소문자
- 출력 방법 : for 문 사용

### - List 예시
```java
public static void main(String[] args) {
    // 선언 방식
    List<String> strList = new ArrayList<>();
    String [] strArray = new String[5];

    // 값을 대입하는 방법
    strArray[0] = "김영";
    strArray[4] = "김사";

    strList.add("java");
    strList.add("python");
    strList.add("javascript");
    strList.add("C#");
    strList.add("C++");
    
    // 출력 방식
    System.out.println(strArray);
    System.out.println(Arrays.toString(strArray));
    System.out.println(strList);
    
    String searchElem1 = "python";
    boolean contains1 = strList.contains(searchElem1);
    System.out.println(searchElem1 + " 포함 여부 " + contains1);    // true
    String searchElem2 = "py";
    boolean contains2 = strList.contains(searchElem2);
    System.out.println(searchElem2 + " 포함 여부 " + contains2);    // false

    String removeElem1 = "javascript";
    boolean isRemoved = strList.remove(removeElem1);
    System.out.println(removeElem1 + " 삭제 여부 : " + isRemoved );
    
    System.out.println("정렬 전 : " + strList);
    Collections.sort(strList); 
    System.out.println("정렬 후 : " + strList);
    
    Collections.sort(strList, Comparator.reverseOrder());
    System.out.println("역순 정렬 후 : " + strList);
    
    // 출력
    for (int i = 0; i < strArray.length; i++) { // 배열
        System.out.print(strArray[i] + " ");
    }
    System.out.println();
    for ( int i = 0; i <strList.size(); i++) {  // List
        System.out.print(strList.get(i) + " ");
    }
}
```

- List의 element 들을 Set에 추가 -> Set명.addAll(List명);
- Set의 element 갯수 -> Set명.size()
- Set 에서 element 들을 추출해서 데이터를 조작하는 것이 불가능
  -> List로 변환해서 출력 및 데이터 가공
### - Set 예시
```java
public static void main(String[] args) {
    // Set 객체 생성
    Set<String> strSet = new HashSet<>();
    // List 객체 생성
    List<String> strList = new ArrayList<>();

    strList.add("java");
    strList.add("java");
    strList.add("python");
    strList.add("react");
    strList.add("react");
    strList.add("react");
    System.out.println(strList);

    // Set에 추가
    strSet.add("TypeScript");
    System.out.println(strSet);

    // List는 그대로 유지, Set 에는 중복을 제거한 element 들이 대입
    strSet.addAll(strList);    
    System.out.println(strList);    
    System.out.println(strSet);

    List<String> modifiedStrList = new ArrayList<>();   // 새로운 List
    modifiedStrList.addAll(strSet); // 중복 제거된 set 요소들을 새로운 List에 대입하는 과정
    Collections.sort(modifiedStrList);
    System.out.println(modifiedStrList);

    for (int i = 0; i < modifiedStrList.size(); i++) {
        System.out.println(modifiedStrList.get(i) + " 언어");
    }
}
```

### - 학생 수와 수학여행지를 입력받아 출력하는 예시
```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    System.out.print("몇 명의 학생이 수학 여행지를 입력하시겠습니까? >>> ");
    int student = scanner.nextInt();

    List<String> fieldTrips = new ArrayList<>();
    String trip = "";
    for (int i = 0; i < student; i++) {
        System.out.print((i+1) + "번 학생의 수학 여행지를 입력하세요 >>> ");
        trip = scanner.next();
        fieldTrips.add(trip);   // 입력 받은 수학 여행지를 List에 저장
    }

    for ( int i = 0; i < fieldTrips.size(); i++) {      // List에 저장된 내용을 출력 
        System.out.println((i+1) + "번 학생의 후보지 : " + fieldTrips.get(i));
    }

    // List -> Set : 중복 제거 후 다시 -> List
    Set<String> fieldTripSet = new HashSet<>();
    fieldTripSet.addAll(fieldTrips);
    List<String> finalFieldTrips = new ArrayList<>();
    finalFieldTrips.addAll(fieldTripSet);

    Collections.sort(finalFieldTrips, Comparator.reverseOrder());   // 역순 정렬

    System.out.println("수학 여행 후보지는 ");
    for(int i = 0; i < finalFieldTrips.size(); i++) {
        System.out.println(finalFieldTrips.get(i));
    }
    System.out.println("입니다.");
}
```