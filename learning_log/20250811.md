### - casting 복습 
- A의 자식 클래스가 여러개 있다고 가정했을 때 그것을 업캐스팅 했을 때
  A가 가지고 있는 부모 메서드를 호출함으로써 다수의 서로 다른 클래스 객체를 통제 가능하다는 장점
  때문에 업캐스팅을 적용하게 됨.
- 다운캐스팅을 해서 각각 클래스의 고유 메서드도 실행시킬 수 있음

```java
// on() / off() 를 필수적으로 구현하기 위해서 interface로 Power 클래스 생성 
public interface Power {
    void on();
    void off();
}

public class Computer implements Power {
    @Override
    public void on() { System.out.println("컴퓨터의 전원을 켭니다."); }

    @Override
    public void off() { System.out.println("컴퓨터의 전원을 끕니다."); }

    // 고유 메서드
    public void compute() { System.out.println("컴퓨터가 연산을 수행합니다."); }
}
public class Mouse implements Power {
    @Override
    public void on() { System.out.println("마우스의 전원을 켭니다."); }

    @Override
    public void off() { System.out.println("마우스의 전원을 끕니다."); }

    public void leftClick() { System.out.println("마우스 왼쪽 클릭"); }
}
```

- 여러 객체들을 한번에 통제하는 클래스
```java
public class CentralControl {
    // 필드 선언 - 배열로 선언하여 각 객체들을 배열에 담음
    private Power[] deviceArray;

    public CentralControl(Power[] deviceArray) {
        this.deviceArray = deviceArray;
    }

    // 메서드 정의
    // Power의 자식 클래스에 해당하는 인스턴스들을 deviceArray 라는 필드에 추가 하는 메서드
    public void addDevice(Power device) {
        
        int emptyIndex = checkEmpty();  // method의 결과값을 변수 emptyIndex에 대입
        if (emptyIndex == -1) {
            System.out.println("더 이상 장치를 연결할 수 없습니다.");
            return;
        }
        deviceArray[emptyIndex] = device;       
        // private로 적용해놔서 method를 경유 / public 이면 main 에서 바로 위의 코드를 작성하면 됨
        System.out.println(device.getClass().getSimpleName() + " 장치가 연결되었습니다.");
    }

    // CentralControlMain 에서 객체 생성을 할 때 deviceArray의 최종 indexNumber는 고정되는데
    // 기존 element를 삭제하면 안되고 (덮어쓰기 x) 비어있는 element에 device 추가를 할 수 있어야 함.
    // -> 배열 내에 null 값이 존재하는지에 대한 체크가 필요
    private int checkEmpty() {  // 정보를 노출할 필요가 없으므로 private로 지정
        // 배열에서 비어있는 index 를 추출 가장 빨리 만나게 되는 null 값을 return
        for(int i = 0; i < deviceArray.length;i++) {
            if(deviceArray[i] == null) {
                return i;           // 배열 내부에 element가 없다면 그 주소지를 return
            }
        }
        return -1;  // 결과값이 없다.
    }

    public void powerOn() {
        // 해당 클래스의 필드인 Power[] 배열 내에 있는 객체들은 기본적으로 Power의 서브 클래스의 객체
        // 즉, on() / off() method 를 공통적으로 지니고 있고 Power 자료형으로 업캐스팅도 되어있음

        for ( int i = 0; i < deviceArray.length; i++) {
            if(deviceArray[i] == null) {
                System.out.println("장치가 없어 전원을 켜지 않았습니다.");
                continue;   // 현재 반복만 종료
            }
            deviceArray[i].on();
        }
    }
    public void powerOff() {
        for (Power arrays : deviceArray ) {
            if(arrays == null) {
                System.out.println("장치가 없어 전원을 끌 수 없습니다.");
                continue;
            }
            arrays.off();
        }
    }

    public void showInfo() {
        for( int i = 0; i < deviceArray.length ; i++) {
            if (deviceArray[i] == null) {
                System.out.println("슬롯 [ " + (i+1) + " ] 번 : Empty");
                continue;
            }
            System.out.println("슬롯 [ " + (i+1) + " ] 번 : " 
                    + deviceArray[i].getClass().getSimpleName());
        }
    }

    // 이제 배열 내부를 돌면서 각 element 들의 고유 메서드들을 실행
    public void performSpecificMethod() {
        for(Power device : deviceArray) {
            // Power의 서브 클래스가 잘못된 다운캐스팅을 하지 않도록 하는 조건문
            if (device instanceof Computer) {
                Computer computer = (Computer) device;
                computer.compute();
            } else if (device instanceof Mouse) {
                Mouse mouse = (Mouse) device;
                mouse.leftClick();
            }  else if (device == null){
                System.out.println("장치가 비어있습니다.");
            } else { 
                System.out.println("아직 지원하지 않는 기기입니다.");
            }
        }
    }
}

// 메인 클래스
public class CentralControlMain {
    public static void main(String[] args) {
        // 각 클래스의 객체 생성
        Computer computer1 = new Computer();
        Mouse mouse1 = new Mouse();

        // centralControl 객체를 만들면서 내부의 필드에 비어있는 Power[] 배열을 집어넣음
        CentralControl centralControl = new CentralControl( new Power[10] );

        centralControl.addDevice(computer1);        // (암시적) 업캐스팅이 이루어짐.
        centralControl.addDevice(mouse1);

        centralControl.powerOn();
        centralControl.powerOff();
        centralControl.showInfo();

        // 고유 메서드 실행
        centralControl.performSpecificMethod();
    }

}
```

- .getClass() -> 클래스명을 return 하는 method + 패키지 경로 포함
  .getClass().getSimpleName() -> 클래스 명만 출력됨.
  method의 결과값을 가지고 다시 . 찍어서 그 다음 method를 호출했음 -> chaining method 라고 함
  return 값의 유형을 명확하게 알고 있어야 그 다음 어떤 method를 실행시킬 것인지를 알 수 있음

- Java의 index 넘버에는 음수값이 없기 때문에 실패를 나타낼 때 -1을 쓰는 경우가 많지만
  0과 너무 가까운 수이다보니 -100 또는 return 값으로 나올 수 없을만한 음수값을 지정하는 경우도 있는데,
  -1 쓰는게 가장 보편적임

- continue : break;는 반복문을 즉시 종료, return은 method를 즉시 종료
  continue의 경우에는 현재 반복만 종료하고 그 다음 반복문으로 넘어감

---

# Object 클래스
- 모든 클래스는 Object 클래스를 상속받는다. 그래서 interface를 implement 할 때나 다른 sub 클래스 만들어서 extends 명령어 입력했을 때
  우리가 직접 만들었던 슈퍼 클래스 이외에 toString() 어쩌고 한 것들이 있었습니다.
    1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속받아서, 클래스 이름과 해시코드(일종의 주소지의 개념)를 return함.
        - 이를 Override 해서 재정의하여 클래스의 정보를 출력할 때 사용함.
        - ObjectTest / ObjectMain 클래스 작성
        - 필드를 정의하고, toString()메서드를 override 해서 필요한 필드를 출력함 
          -> Main 단계에서 특정 객체의 특정 필드를 객체의 이름만으로 출력이 가능함. (sout(객체명);으로 가능 / sout(객체명.showInfo()가 아니라.))
    
    2. equals() : 두 객체가 '논리적으로 같은지'를 비교하는 메서드(주소지의 차이가 아니라.)
                  기본적으로 Object 클래스의 equals() 메서드는 두 객체의 참조 주소를 비교합니다.
        - 형식 : 객체명1.equals(객체명2) -> 객체명1과 객체명2의 참조주소가 동일한지 확인함. - 3형식 문장으로 해석하시면 됩니다. SVO.

    3. hashCode() : 객체를 정수 값(해시값)으로 변환(16진수가 아니라). 해시값은 주로 해시 기반 컬렉션에서 사용됩니다.(추후 수업 예정)
       - equals() 메서드를 재정의하게 되면 반드시 hashCode() 메서드도 재정의해야만 합니다. 왜냐면 동일한 객체(equals == true)는 
         동일한 해시 코드를 가져야하기 때문인데, 문제는 해시 코드가 같다고 해서 또 equals()가 true가 아닌 경우가 있습니다.

```java
public class ObjectTest {
    // 필드 선언
    private String name;
    private String address;

    // 생성자
    public ObjectTest() { }

    public ObjectTest(String name, String address) {
        this.name = name;
        this.address = address;
    }

    // getter / setter
    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getAddress() { return address; }

    public void setAddress(String address) { this.address = address; }

    public void showInfo() {
        System.out.println("이름 : " + this.name);
        System.out.println("주소 : " + this.address);
    }

    @Override
    public String toString() {
        return "ObjectTest{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

public class ObjectMain {
    public static void main(String[] args) {
        ObjectTest objectTest1 = new ObjectTest();

        objectTest1.setName("홍길동");
        objectTest1.setAddress("부산광역시 중구");
        objectTest1.showInfo();

        System.out.println(objectTest1);
        // objectTest1.toString() -> 작성했을 때 toString 불필요한 메서드라고 뜸 객체명 만으로 toString 호출 가능

        String[] strArray = {"안녕하세요", "안녕"};
        boolean result1 = "안녕하세요" == strArray[0];   // true
        boolean result2 = example == strArray[0];   // false

        String example2 = new String("안녕하세요");
        boolean result3 = "안녕하세요" == example2;  // false
        boolean result4 = strArray[0] == example2; // false
        boolean result5 = strArray[0].equals(example2); // true
    }
}
```
### - object 예시
```java
public class Teacher {
    private String name;
    private String school;

    public Teacher(String name, String school) {
        this.name = name;
        this.school = school;
    }

    // Getter / setter
    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public String getSchool() { return school; }

    public void setSchool(String school) { this.school = school; }
    
    @Override
    public String toString() { return name + "선생님의 근무지는 " + school +"학교입니다."; }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Teacher teacher = (Teacher) o;
        return Objects.equals(name, teacher.name) && Objects.equals(school, teacher.school);
    }

    @Override
    public int hashCode() { return Objects.hash(name, school); }
}

public class TeacherMain {

    public static void main(String[] args) {
        Teacher teacher1 = new Teacher("박선영" , "코리아아이티");
        Teacher teacher2 = new Teacher("박선영" , "코리아아이티");

        boolean result1 = teacher1.equals(teacher2);
        System.out.println(result1);        // true
        // 재정의 전과 후가 결과값이 다름 Teacher 에서 .equals()를 재정의하기 전 -> false
        // 그땐 teacher1 과 teacher2의 주소지까지를 확인하여 같은지 아닌지의 여부를 판단했다면,
        // 재정의 이후에는 field에 입력된 데이터가 동일한지만을 체크.

        Class tClass = teacher1.getClass();
        System.out.println(tClass);                                  // 결과값 : class ch16_objects.teacher.Teacher
        System.out.println(tClass.getSimpleName());                  // 결과값 : Teacher
        System.out.println(teacher1.getClass().getSimpleName());     // 결과값 : Teacher
        
        Field[] fields = tClass.getDeclaredFields();
        System.out.println(fields);     // 주소지 출력됨
        for ( int i = 0 ; i < fields.length; i++) {
            System.out.println("필드명 출력 : " + fields[i].getName());
            System.out.println("패키지명 + 클래스명 출력 : " + fields[i].getType());
            System.out.println("클래스명 출력 : " + fields[i].getType().getSimpleName() + "\n");
        }
        
        Method[] methods = tClass.getDeclaredMethods();
        for ( int i = 0; i < methods.length; i++) {
            System.out.println("메서드명 출력 : " + methods[i].getName());
            System.out.println("리턴 타입 출력 : " + methods[i].getReturnType() + "\n");
        }
        
        ch16_objects.Teacher teacher3 = new ch16_objects.Teacher("박선영", "코리아아이티");  // 새로운 객체

        boolean result2 = teacher1.equals(teacher3);
        System.out.println(result2);        // 결과값 : false
    }
}
```

---

# Lombok
메뉴바 -> 설정 -> 좌측에 plugins(플러그인) 석택 -> Lombok 검색 -> 설치 후
disabled/비활성화 라고 나와있으면 활성화된 상태라는 뜻입니다.

chrome -> maven repositories 로 들어가서 lombok 검색 -> 웬만하면 최신버전
그리고 저희는 빌드 시스템이 gradle 이기 때문에(그리고 코틀린이 아니기 때문에), groovy short로 복사
그리고 annotationProcessor도 꼭 적용해야 합니다.
```
dependencies {
implementation 'org.projectlombok:lombok:1.18.38'
testImplementation platform('org.junit:junit-bom:5.10.0')
testImplementation 'org.junit.jupiter:junit-jupiter'
annotationProcessor 'org.projectlombok:lombok:1.18.38'
}
```

이상과 같이 작성되어야 합니다. (이렇게 해두면 깃허브에 올라가니까 나중에 복사해서 쓰시는게 속편할 수도 있습니다.)

# Lombok 주요 annotation
1. @Getter / @Setter 
    - class level 에 작성할 경우 getter / setter 메서드를 자동 생성
    - field level 에 작성할 경우 해당 필드에만 메서드 생성
    - 주의 : 객체마다 다른 값을 갖게 되는 비정형(non-static) 필드에 대해서만 적용됨.
    ```java
    @Getter
    @Setter
    public class Person {
        private  String name;
        private int age;
    }
    ```

2. @ToString
   - toString() 메서드를 자동으로 생성. 근데 문제는 재정의가 안되고 Lombok 라이브러리 default 형태만 튀어나오기 때문에
     결과적으로 원하는 부분만 보여주기 위해서는 override methods(alt + ins) 를 쓰는 경우가 많을겁니다.

3. @EqualsAndHashCode
    - equals() / hashCode() 메서드를 자동 생성. 객체의 동일성 비교 로직을 구현할 때 사용
      - 아까 배웠던 것처럼 equals()를 재정의하면 hashCode()도 반드시 같이 재정의 해야하기 때문에 어노테이션도 세트로 묶여있음.
   
4. @NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor
    - @NoArgsConstructor : argument가 없는 기본 생성자를 생성
    - @RequiredArgsConstructor : final 또는 `@NonNull` 어노테이션이 붙은 필드만 필수적으로 요구하는 매개변수 생성자를 생성
    - @AllArgsConstructor : 모든 필드를 argument로 요구하는 매개변수 생성자

    ```java
    @NoArgsConstructor
    @RequiredArgsConstructor
    @AllArgsConstructor
    public class Person {
        @NonNull
        private String name;
        private int age;
    }
    
    public class PersonMain {
        public static void main(String[] args) {
            Person person1 = new Person();        
            Person person2 = new Person("김이");   
            Person person3 = new Person("김삼", 20);
        }
    }
    ```

5. @Data
   - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor가 다 들어가있는 종합 패키지 어노테이션
     그래서 제일 많이 쓰입니다.

    그러다보니까 수강생들이 클래스 만들 때 제일 먼저 하는 방식 : 
    ```java
    @Entity
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class Student {
        private String name;
        private int age;
        private double score;
    }
    ```

    ```java
    import lombok.Data;
    import lombok.Setter;
    
    @Data       // 여기에 어노테이션을 달면 class level
    public class UserEntityLombok {
        private int userName;
        @Setter // 여기에 달면 field level
        private int password;
        private String email;
        private String name;
    }
    
    public class UserEntityMain {
        public static void main(String[] args) {
            UserEntityLombok user1 = new UserEntityLombok();
    
            // 정의하지 않은 setter 사용
            user1.setName("김이");
            user1.setEmail("b@test.com");
            user1.setPassword(1234);
            user1.setUserName(2);
    
            // getter 사용
            System.out.println("제 이름은 " + user2.getName() + "입니다.");
    
            // toString()도 사용
            System.out.println(user2);
        }
    }
    
    ```

6. @Builder - 추후 수업 예정