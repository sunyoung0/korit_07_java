# Method

## 정의

Java에서는 함수(function)의 개념과 동일함.
JavaScript / Python 에서는 function / method 의 개념이 분리되어 있으나
Java는 모든 함수가 클래스에 종속되어 있기 때문에 method로 통일

function vs method

근데 그러면 용어를 왜 분리하는가?

- 기본적으로 클래스 내부에 함수를 정의하게 되면 이를 '메서드'라고 합니다.
  Java는 모든 함수들이 특정 클래스에 종속돼있기 때문에 전부 다 메서드에 해당됩니다.

그래서 다른 언어를 배우게 된다면 '함수의 호출 방식'과 '메서드의 호출 방식' 상에서의 차이가 존재하지만,
현재 저희 수업을 기준으로는 전부 다 method에 해당하고,
이에 따라서 제가 Java 수업 중인데 갑자기 함수 어쩌고 하면 그냥 메서드라고 알아들으시면 됩니다.

하지만 추후에 차이가 생깁니다.

## 용어 정리
1. method 정의(def - define) : 사용자가 메서드를 새로 만드는 것을 의미
2. method 호출(calling) : 만들어진(미리 만들어진) 메서드를 실행시키는 것을 의미
3. 매개변수(parameter) : 특정 메서드에 필수적으로 요구되어지는 변수
4. 출력값 / 결과값 / 리턴값(return) : 메서드의 호출 결과 생성되는 자료(없을 수도 있음/output)
5. 인수 / 인자(argument) : 사용자가 메서드에 전달하는 입력(input)

## Java 상에서의 method
예를 들어, '사진을 찍는다' 라는 행위에 대해서
1. 주머니에서 폰을 꺼내고
2. 잠금 화면을 풀고
3. 카메라를 켜고
4. 사진을 찍고자 하는 대상에 폰을 조준하고
5. 셔터를 누른다
   라는 과정이 존재합니다.
   그런데 제가 어제 설명했듯이 컴퓨터는 생각보다 너무너무너무 멍청하기 때문에 '사진을 찍는다'라고 명령을
   내리는 것으로는 충분하지 않고, 1-6까지의 명령어를 순서대로 입력해줘야만 합니다.

하지만 매번 이렇게 하는 것이 번거롭기 때문에 우리는 '사진을 찍는다' 라는 일련의 동작을 하나의 메서드로 이름 붙이고,
그 내부에 1-6 까지의 명령어를 미리 입력해두는 과정을 거치게 되는데, 이를 매서드 '정의'라고 합니다.

그리고 실제로 컴퓨터에게 '사진을 찍는다' 라는 명령을 내리게 되는 것을 메서드 '호출'이라는 표현이 됩니다.

그리고 여러분의 폰이 아이폰인지 안드로이드폰인지에 따라서 잠금화면을 푸는 방식 등이 달라지겠죠.
그래서 특정한 폰을 지니고 있음을 컴퓨터에게 알릴 필요가 있을 겁니다.
이를 argument 라고 할 수 있습니다.
그리고 사진 찍으면 사진 결과물이 남겠죠.
이것이 return에 해당하는 것이라고 볼 수 있겠습니다.

```java
    // 1. [ x | x ] [입력값 / 출력값]
    public static void call1() {
        System.out.println("[ x | x ]");
    }
    
    // 2. [ o | x ]
    public static void call2(String example) {
        System.out.println("[ o | x ]");
        System.out.println("영어 인사 : " + example);
    }
    
    // 3. [ x | o ]
    public static String call3() {
        String example = "안녕하세요";
        System.out.println("[ x | o ]");
        return example;
    }
    
    // 4. [ o | o ]
    public static double call4(double score) {
        System.out.println("[ o | o ]");
        System.out.println("해당 과목은 3학점짜리입니다.");
        return score * 3;
    }

    public static void main(String[] args) {
        // 메서드 호출 영역
        call1();
        call2("hello");
        call3();
        
        // return 값을 출력하기 위해서는 출력문을 써야함
        System.out.println(call3());
        
        String name = "김일";
        System.out.println(name + " 학생의 점수는 " + call4(4.5) + "점입니다.");
        // 연산을 하기 위해서 return 값이 필요하다. 실행단계에서 결과값을 조작
    }

```
return이 있는 이유는 데이터의 조작을 위해서임
그리고 특정 메서드의 결과값이 다른 메서드의 인자(argument)로 사용될 수도 있음
sout 출력문을 넣으면 데이터의 가공이 불가능

함수형 프로그래밍(Functional Programing) :
메서드1의 return 값이 메서드2의 argument가 되고, 메서드2의 return 값이
메서드 3의 argument 가 되는 방식으로,
첫번째 메서드로부터 마지막 메서드까지의 흐름을 통해 프로그램이 이어지는 코딩 방식

```java
    // 예시
    public static String introduce(String name, int age) {
        return "제 이름은 " + name + "이고, 나이는 " + age + "살입니다.";
    }
    
    public static void main(String[] args) { 
        String myName = "김일";
        int myAge = 10;
        System.out.println(introduce(myName, myAge));   
        // myName / myAge 라는 결과값을 우리가 정의한 introduce()메서드의 argument로 사용
    }
```
### - 별 찍기 로직을 메서드화 해서 메인에서 출력하기
```java
    public static String getStar() {
        String result = "";

        // method 내부에서 method 호출 가능
        Scanner scanner = new Scanner(System.in);

        int rows = 0;
        int option = 0;
        System.out.println("몇 줄짜리 별을 생성하시겠습니까? >>> ");
        rows = scanner.nextInt();

        System.out.println("1. 왼쪽으로 치우친 증가하는 별");
        System.out.println("2. 오른으로 치우친 증가하는 별");
        System.out.print("선택하세요. >>> ");
        option = scanner.nextInt();

        if(option == 1) {
            for (int i = 0; i < rows + 1; i++) {
                for(int j = 0; j < i; j++) {
                    result += "*";
                }
                result += "\n";
            }
        } else if (option == 2) {
            for (int i = 0; i < rows + 1; i++) {
                for (int j = 0; j < rows - i; j++) {
                    result += " ";
                }

                for (int k = 0; k < i; k++) {
                    result += "*";
                }
                result += "\n";
            }
        } 
        else {
            result = "해당 기능이 없습니다.";
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(getStar());  // 메서드 호출 결과를 print
    }
```

---

### 메서드 오버로딩 (method overloading)
매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서 동일한 메서드명을 지는 메서드들을 정의할 수 있다.

메서드를 여러개 만들다보면 이름만으로 차이를 두는 것이 한계가 있음

즉, 메서드명은 동일하고, 매개변수에 들어가는 자료형, 갯수를 달리하게 되면 서로 다른 메서드로 받아들임

overloading의 장점 :
동일한 기능을 하는 메서드를 정의할 때 메서드 명이 필요
ex) String 자료형끼리 연결해주는 메서드와 int 끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때,
add, plus, connect 등의 메서드를 정의했다면
다음 합 연산을 하는 (예를 들어 double 자료형을 지니는) 메서드 명을 정하는 것이 번거롭다.
이러한 부분의 해결을
public void add(String example1, String example2) { 로직 }

public void add(int example1, int example2) { 로직 }

public void add(String example1, String example2, String example3) { 로직 }

와 같은 식으로 메서드 명을 동일하게 가져가면서 차이를 둘 수 있음

```java
    // 메서드 정의영역
    public static void add() {
        System.out.println("add()");
    }
    
    // overloading 적용
    public static void add(String s) {  // 매개변수만 있고 return 값은 없음
        System.out.println("add(String s)");
        System.out.println(s);
    }
    
    public static void add(int a, String s) {
        System.out.println("add(int a, String s)");
        System.out.println(a + " / " + s);
    }
    
    public static void add(String s, int a) {
        System.out.println("add(String s, int a)");
        System.out.println(a + " / " + s);
    }
    
    public static void main(String[] args) {
        //메서드 호출 영역
        add();
        add("안녕하세요");
        
        // 매개변수의 순서가 중요함
        add(8, "월 1일");
        add("월 1일", 8);
    }
    
```

### - 과목의 수를 입력받아 점수의 합과 평균을 구하는 메서드 예시
```java
    import java.util.Scanner;

    // method 정의 (매개변수 x, return x)
    public static void calcSumAndAvg() {
    
        Scanner scanner = new Scanner(System.in);
        double sum = 0;
        double avg = 0;
        int numOfSubs = 0;
    
        System.out.print("몇 과목의 점수를 입력하시겠습니까? >>> ");
        numOfSubs = scanner.nextInt();
    
        for (int i = 0; i < numOfSubs; i++) {
            System.out.print((i+1) + " 과목의 점수를 입력하세요 >>> ");
            sum += scanner.nextDouble();
        }
        avg = (sum / numOfSubs);
        System.out.println("총합은 " + sum + "이며, 평균은 " + avg + "입니다.");
    }
    
    public static void main(String[] args) {
        // 메서드 호출 영역
        calcSumAndAvg();
    }
    
```
다른 클래스에서 클래스이름.메서드(); 해서 불러와서 쓸 수 있다.

---

# 클래스
클래스 : 객체를 생성하기 위한 설계도 = 틀 / 청사진
현실 세계의 개념을 프로그래밍으로 표현할 때,
"특정 사물이나 개념의 특징(속성)"과 "행위(메서드)"로 정의함

객체(Object) : 클래스를 설계도로 가정했을 때, 실제 사용할 수 있는 인스턴스는 객체라고 함

객체와 인스턴스의 관계 : 객체는 포관적인 개념으로 클래스에서 생성된 모든 것을 객체라고 표현
인스턴스는 특정 객체가 어떤 클래스의 구현체인지를 강조하는 표현

객체 생성 방법 : 클래스명 객체명 = new 클래스명();

객체에 값 대입 방법 : 객체명.속성명 = 데이터

객체의 메서드 호출 방법 : 객체명.메서드명();

```java
    public class ClassA {
        // 필드(속성) / 인스턴스 변수 / 멤버 변수 정의
        int num;
        String name;
    
        // 메서드 정의
        void callName() {
            System.out.println(name + "을 부릅니다.");
        }
    }

public class ClassAMain {
    public static void main(String[] args) {

        ClassA classA1 = new ClassA();
        classA1.num = 1;
        classA1.name = "김일";

        System.out.println(classA1.name + " 학생의 학번은 "+ classA1.num + "번입니다.");

        // 메서드 호출
        classA1.callName();

    }
}
```

---

### 생성자
생성자는 객체가 생성될 때 호출되는 특별한 '메서드'

객체 생성 예시
클래스명          객체명      = new 클래스명();
ExampleClass    example    = new ExampleClass();

특징 :
1. 클래스의 이름과 생성자의 이름은 동일하다. (다른 메서드들과 달리 대문자로 시작)
2. return 값이 없다. -> 즉, call1() / call2() 유형으로 생각할 수 있다.
3. 객체 초기화 : 생성자는 객체의 필드 '초기화'를 담당한다.

생성자 정의 방식 
1. 기본 생성자 : 매개변수가 없는 생성자
        (클래스를 만들 때 default로 생성되는 형태로 정의하지 않아도 될 때가 있음) 
2. 매개변수 생성자 : 하나 이사의 매개 변수를 가지는 생성자

- 매개변수 생성자가 하나라도 만들어지면 default로 만들어진 기본 생성자가 사라지기때문에
기본 생성자와 매개변수 생성자를 둘 다 사용하고 싶다면 기본 생성자도 따로 '명시적으로 정의'해야만 함.

```java
public class Constructor {  // 생성자 클래스
    // 필드 선언
    int num;
    String name;

    // 기본 생성자 -> 원래 기본적으로 만들어짐, 클래스와 동일한 메서드명
    Constructor() {
        System.out.println("NoArgsConstructor(기본생성자)");
    }

    // 매개변수 생성자 정의 -> 기본적으로 만들어지지 않음 개발자가 정의해야 함
    Constructor(int number) {
        System.out.println("RequiredArgsConstructor(int 매개변수를 필수로 요구하는 생성자");
        this.num = number;  // this : 해당 클래스에서 객체를 생성하게 되면 객체 이름으로 대체됨.
    }
}    

public class ConstructorMain {  // 생성자 main 클래스
    public static void main(String[] args) {
        // 기본 생성자를 통한 객체 생성
        Constructor constructor1 = new Constructor();

        // int 매개변수 생성자를 통한 객체 생성
        Constructor constructor2 = new Constructor(1);
    }
}
```

```java
// 매개변수가 있는 생성자 예시
public class Constructor {
    Constructor(String title) {
        System.out.println("RequiredArgsConstructor(String 매개변수를 필수로 요구하는 생성자");
        this.name = title;
    }
}

public class ConstructorMain {  // 생성자 main 클래스
    public static void main(String[] args) {
        Constructor constructor = new Constructor("이름");
        System.out.println(constructor.name);
    }
}
```

### - Car의 인스턴스 객체 생성 후 값을 대입하고 메서드 호출 예시
```java
public class Car {
    // 필드 선언
    String color;
    int speed;

    // 메서드 정의
    void drive() {
        System.out.println(color + " 자동차가 주행중입니다.");
    }

    void brake() {
        System.out.println(color + " 자동차가 멈췄습니다.");
    }

    void displayInfo() {
        System.out.println("이 차의 색깔은 " + color + "색이고,");
        System.out.println("최고 속도는 " + speed + "km/h 입니다.");
    }
}

public class CarMain {
    public static void main(String[] args) {
        // 객체 생성
        Car myCar = new Car();
        // 필드에 값 대입
        myCar.color = "빨강";
        myCar.speed = 160;

        Car yourCar = new Car();
        yourCar.color = "노랑";
        yourCar.speed = 180;

        // 메서드 호출
        myCar.drive();
        myCar.displayInfo();
        yourCar.brake();
        yourCar.displayInfo();
    }
}
```

# 생성자 관련 정리(롬복)
1. NoArgsConstructor - 기본생성자
2. RequiredArgsConstructor - 매개변수 생성자
3. AllArgsConstructor - 클래스의 전체 필드를 전부 요구하는 매개변수 생성자