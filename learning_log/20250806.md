### -  내부 element 값들의 점수 범위를 조사하고 각 몇명인 지 출력하는 예시
```java
public static void main(String[] args) {
    int[] grades = {0, 0, 0, 0, 0};
    // A,B, C, D, F 변수를 하나하나 설정하는 것이 아니라 하나의 배열을 만들어서
    // A에 해당하면 grades[1]++ 이렇게 해주면 변수를 하나하나 설정할 필요가 없다. 

    for ( int i = 0; i < scores.length; i++) {
        if(scores[i] > 89) {
            grades[0]++;
        } else if(scores[i] > 79) {
            grades[1]++;
        } else if(scores[i] > 69) {
            grades[2]++;
        } else if(scores[i] > 59) {
            grades[3]++;
        } else {
            grades[4]++;
        }
    }
    System.out.println("A 학생 수 : " + grades[0]);
    System.out.println("B 학생 수 : " + grades[1]);
    System.out.println("C 학생 수 : " + grades[2]);
    System.out.println("D 학생 수 : " + grades[3]);
    System.out.println("F 학생 수 : " + grades[4]);
}
```

### - 배열의 argument 총합과 평균을 구하는 메서드 작성
```java
// 접근 지정자 public 으로 method 들을 정의했기 때문에 calsSum() / calcAvg()를 다른 클래스에서도 사용 가능
public int calcSum(int[] intArray) {
    int sum = 0;

    for (int i = 0; i < intArray.length; i++) {
        sum += intArray[i];
    }
    return sum;
}

public double calcAvg(int[] intArray) {
    // 메서드 내에서 메서드를 호출할 수 있으므로 위에 만든 sum 메서드 호출
    double avg = (double)calcSum(intArray) / intArray.length;

    return avg;
}

public static void main(String[] args) {

    // 위에 정의한 method 호출하기 위해 객체 생성
    Array08 array08 = new Array08();
    
    int[] scores = { 100, 97, 55, 24, 49, 60, 20, 77, 89 };

    System.out.println("총합 : " + array08.calcSum(scores) + "점");
    System.out.println("평균 : " + array08.calcAvg(scores) + "점");
}
```

---

## 향상된 for문 (Enhanced For loop) - 이중 for문
일반 for 문과의 차이점 : arr01.length와 같은 방식으로 일종의 field 참조를 통해 int 값을 추출하여 대입해야만 했음
                      그런데 for (int i = 0; ...) 부분에서 int i 는 for문 내부에서 선언되고, 내부에서만 사용이 가능

향상된 for문 : 배열 내의 element에 for문 내부에서만 사용하는 변수에 대입하는 방식으로
             index 넘버(주소지)의 사용 없이 적용할 수 있는 for 반복문

제약 : 읽기만 되고, 쓰기가 안됨

형식 :
for(자료형 변수명 : 반복가능객체(배열)) {
    반복 실행문;
}

### - 향상된 for문 예시 1
```java
public static void main(String[] args) {
    int[] nums = new int[200];

    // 1부터 200까지 일반 for문 형태로 1 2 3 ... 199 200 으로 출력
    for(int i = 0; i < nums.length; i++) {
        nums[i] = (i+1);
        System.out.print(nums[i] + " ");
    }

    // 향상된 for 문으로 출력
    for( int number : nums ) { // int[]
        System.out.print(number + " ");
        // 첫번째 반복에서 nums 의 첫번째 element인 1을 number에 대입 -> 대입이 된 상태로 출력문 실행 "1 "이 출력
        // 마무리(마무리 시점은 마지막 element 대입후 반복 실행문 실행 후)
        // 이후에 반복문 바깥에서는 int i 와 동일하게 number 변수를 사용할 수 없음
    }

}
```
### - 향상된 for문 예시 2
```java
public static void main(String[] args) {
    String[] persons = { "김일", "김이", "김삼", "김사", "김오" };
    /*
        실행예
        1 번 : 김일
        ...
        5 번 : 김오
     */
    for  ( int i = 0; i < persons.length; i++) {
        System.out.println((i+1) + " 번 : " + persons[i]);
    }

    int count = 0;
    // 향상된 for 문
    for (String person : persons) {
        System.out.println(++count + " 번 : " + person);
    }
}
```

---

# cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 import 해옴
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        // 사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        
        // 막 내부 로직들 엄청나게 써놓고 있다고 가정하다가 저 밑에서 갑자기
        // students가 튀어나왔다고 가정해보겠습니다.
        
        if(randomNum < 0) {
            // 이런 방식으로 실행문을 써야 합니다. 라는 식으로 회사에서 정하는 경우가 있음
        }
    }
}
```

---

### 배열의 출력
System.out.println(arr01); 과 같은 출력문을 작성했을 때 주소값만 나옴

변형이 없고 배열 자체를 확인하고 싶을 때  Arrays 클래스를 사용하고, 
'정적' 메서드인 .toString(배열명)을 사용하면 배열 전체를 출력할 수 있음

동일한 method 명이라고 하더라도 어떤 클래스에 종속되어있는가에 따라 다른 결과값을 지닐 수 있음

- 배열의 전체 출력 -> Arrays.toString(배열명)
- 2차 배열의 출력 : Arrays.deepToString(배열명)
- 배열 정렬 -> 오름차순 : Arrays.sort(배열명)
             내림차순 : Arrays.sort(배열명, Comparator.reverseOrder())
```java
public static void main(String[] args) {
    int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    // 배열의 전체 출력 예시
    System.out.println(Arrays.toString(numbers));

    Integer[] nums = { 3, 6, 7, 1, 9, 2, 10, 5, 4, 8 };
    System.out.println("정렬 전 배열 : " + Arrays.toString(nums));

    // 오름 차순 정렬
    Arrays.sort(nums);      // 얘의 결과값이 void 니까 원본 배열을 바꿈
    System.out.println("오름차순 정렬 후 배열 : " + Arrays.toString(nums));

    // 내림 차순 정렬
    Arrays.sort(nums, Comparator.reverseOrder());
    System.out.println("내림차순 정렬 후 배열 : " + Arrays.toString(nums));
}
```

---

## 다차원 배열(Multi-Dimensional Array) - 2차원 배열
다차원 배열은 2차원 이상의 배열을 의미하지만, 개발 환경 상 2차원 배열 이상을 다루는 경우는 극히 드물다.

형식 :
int[][] arr01 = new int[크기][크기];    - 선언 방식 # 1

int[][] arr02 = new int[크기][];    - 선언 방식 # 2

int[][] arr03 = { {1, 2}, {3, 4}, {5, 6} }    - 선언 방식 # 3 및 초기화

2차원 배열 선언 시, 열의 크기는 지정하지 않아도 되지만, 행의 크기는 항상 지정해야함. 

-> 2번 방식

     1열 2열 (column)
      ↆ  ↆ
    { 1, 2 },   → 1행 (row)     가로줄을 '행'
    { 3, 4 },   → 2행
    { 5, 6 }    → 3행

### - 2차원 배열 예시
```java
public static void main(String[] args) {

    int[][] arr03 = { {1, 2}, {3, 4}, {5, 6} };
    // arr03[0][0] = 1 , arr03[0][1] = 2, arr03[1][0] = 3, arr03[1][1] = 4, arr03[2][0] = 5, arr03[2][1] = 6
    System.out.println(arr03[2][0]);    // 결과값 : 5
    System.out.println(arr03[2]);       // 결과값 : [I@36baf30c
    System.out.println(arr03);          // 결과값 : [[I@7a81197d

    System.out.println(Arrays.toString(arr03)); // 결과값 : [[I@5ca881b5, [I@24d46ca6, [I@36baf30c]

    // 2차 배열의 element 추출 -> 중첩 for 문 사용
    for (int i = 0; i < arr03.length; i++) {
        for ( int j = 0 ; j < arr03[i].length; j++) {
            System.out.println(arr03[i][j]);
        }
    }

    // 향상된 for 문으로 2차 배열 내부의 element를 추출
    for(int[] arr : arr03) {
        for(int arr1 : arr) {
            System.out.print(arr1 + " ");
        }
        System.out.println();
    }
}
```

### - 1부터 100까지의 숫자를 2차 배열에 순서대로 값을 넣고 향상된 for 문으로 출력문 작성 예시
```java
public static void main(String[] args) {

    int[][] nums = new int[20][5];

    int count = 0;
    for (int i = 0; i < nums.length; i++) {
        for(int j = 0; j< nums[i].length; j++) {
            // 값을 대입할 때 주소지를 두개 다 설정한 다음에 데이터를 넣어야함
            nums[i][j] += ++count;
        }
    }

    for(int[] num : nums) {
        for(int number : num) {
            System.out.print(number + " ");
        }
        System.out.println();
    }

    // 이렇게 작성하면 [1, 2, 3, 4, 5] [6, 7, 8, 9, 10] ... 이런식으로 나옴
    for (int[] num : nums) {
        System.out.println(Arrays.toString(num));
    }

    // 2차 배열의 출력 : Arrays.deepToString(배열명);
    System.out.println(Arrays.deepToString(nums));
}
```

---

# 상속(Inheritance)
- 객체 지향 프로그래밍(OOP)의 핵심 개념 중 하나로, 기존 클래스(부모(슈퍼) 클래스)의
field와 method를 재사용하여 새로운 클래스(자식(서브) 클래스)를 만드는 것을 의미함.
- 상속을 지시하는 키워드 : `extends`
                 형식 : 자식클래스 extends 부모클래스

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가 재사용 가능
  - 동물(Animal) 클래스가 있고, 이를 상속 받는 개(Dog) / 고양이(cat) 클래스가 있다고 가정했을 때,
    동물의 공통적인 field(이름 / 나이 등)와 행위(걷기 / 먹기 등)을 부모 클래스에 정의,
    개와 고양이는 각각 고유한 특성 (짖기 / 우다다다 )을 추가할 수 있음
- 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고
  또 Cat 에다가 이름 / 나이 / 먹기 / 우다다다를 정의하는 등의 공통된 부분

  정의하는 일 없이 특정 field 및 메서드만 정의하면 됨. -> 중복된 코드를 줄일 수 있다.

## 상속의 특징
1. 단일 상속
    - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속받을 수 있어 상속 구조가 간단하고 명확함
2. super 키워드
    - 클래스의 생성자 및 setter 에서 학습한 this와 유사한 개념으로
      부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함(두가지 사용법이 있습니다.)
3. _method override_
    - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의`할 수 있음. 이를 통해 자식 클래스는 부모 클래스의 기본 동작을
      자신만의 방식으로 변경 가능
    - 예시
      - Animal 클래스의 걷기를 Dog가 상속 받고, 네발로 걷기로 _재정의_ , Human 클래스가 걷기를 상속 받고
        두 발로 걷기로 _재정의_가 가능합니다.
4. final 키워드 - 클래스에 final이 붙으면 상속 불가
    - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 - 동일한 코드를 반복적으로 작성할 필요 X
2. 유지 보수의 용이성
   - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에 위계 파악 후 수정하면 됩니다.
3. 객체 간 관계 표현 - IS-A 관계를 명확히 나타냄
   - IS-A 
   '개'는 '동물'의 일종이다. 와 같은 예시로, IS-A는 is a kind of의 축약어
   - 그래서 우리가 미리 만들어둔 Animal / Tiger / Human의 클래스를 예로 들었을 때
   - Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

- @Override 가 붙어있으면 해당 메서드는 상속 받은 것

### - Animal 클래스와 Tiger 클래스를 활용한 상속 예시 
```java
public class Animal {   // 부모 클래스
    // 필드 정의
    private String animalName;
    private int animalAge;

    public Animal() { }     // 기본 생성자

    public Animal(String animalName, int animalAge) {   // AllArgsConstructor
        this.animalAge = animalAge;
        this.animalName = animalName;
    }

    // Getter / Setter
    public void setAnimalName(String animalName) {
        this.animalName = animalName;
    }
    public void setAnimalAge(int animalAge) {
        this.animalAge = animalAge;
    }
    public String getAnimalName() {
        return animalName;
    }
    public int getAnimalAge() {
        return animalAge;
    }

    // 메서드
    public void move() {    
        System.out.println("움직입니다.");
    }
}
```

```java
public class Tiger extends Animal {     // 자식 클래스
    // field와 getter / setter은 없지만 Tiger의 고유 메서드는 또 따로 정의 가능
    // 고유 메서드 # 1
    public void hunt() {
        System.out.println(getAnimalName() + "이(가) 사냥을 합니다.");
    }

    // 고유 메서드 # 2 오버로딩 적용
    public void hunt(String prey) {
        System.out.println(getAnimalName() + "이(가) " + prey + "를 사냥합니다.");
    }

    // 재정의된 methods : 부모 메서드의 결과값과 다르게 작성한다면 전부 재정의에 해당함.
    @Override           
    public String getAnimalName() {
        return super.getAnimalName()+ "님";
    }
    @Override
    public void setAnimalName(String animalName) {
        super.setAnimalName(animalName);
    }
    @Override
    public int getAnimalAge() {
        return super.getAnimalAge();
    }
    @Override
    public void setAnimalAge(int animalAge) {
        super.setAnimalAge(animalAge);
    }
    @Override   // 이 경우는 method 명만 동일하고 전부 다 재정의 했습니다.
    public void move() {
        System.out.println("호랑이가 네발로 걷습니다.");
    }
}
```

```java
public static void main(String[] args) {    // 메인 부분

    Animal animal1 = new Animal();

    // Tiger 객체 생성
    Tiger tiger1 = new Tiger();

    tiger1.setAnimalName("푸바오");
    tiger1.setAnimalAge(3);

    System.out.println("이 호랑이의 이름은 " + tiger1.getAnimalName() +"입니다.");
    System.out.println(tiger1.getAnimalAge() +"살 입니다.");

    tiger1.hunt();
    tiger1.hunt("물고기");

    tiger1.move();      // 재정의된 move() 호출
    animal1.move();     // 부모 method 원본 그대로 호출
}
```

### super 키워드
1. super();             -> 부모 생성자를 호출한다는 의미
2. super.메서드명();      -> 부모 클래스의 메서드를 호출한다는 의미

부모-자식의 상속관계가 성립되어 있을 때, 부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면
자식 클래스에서 완벽한 기본 생성자를 만드는 것이 불가능
자식 클래스의 객체 생성 시 필수적으로 '부모 클래스의 생성자를 호출'하기 때문

객체를 생성할 때 A a = new B; 같은 형태의 객체 생성 방식이 튀어나올수도 있음

### - Item 클래스와 Product 클래스를 통한 상속 예시
```java
public class Item { // 부모 클래스
    // 필드 선언
    private String name;
    private String category;
    
    public Item(String name, String category) {     //  AllArgsConstructor
        this.name = name;
        this.category = category;
    }

    // Getter / Setter
    public void setCategory(String category) {
        this.category = category;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public String getCategory() {
        return category;
    }
}
```

```java
public class Product extends Item { // 자식 클래스
    // 자식 고유의 field 정의
    private int price;
    private int stock;
    
    // Product 클래스의 AllArgsConstructor
    public Product(String name, String category, int price, int stock) {
        super(name, category);
        this.price = price;
        this.stock = stock;
    }

    // 자식 고유의 field에 대한 getter / setter
    public void setPrice(int price) {
        this.price = price;
    }
    public void setStock(int stock) {
        this.stock = stock;
    }
    public int getPrice() {
        return price;
    }
    public int getStock() {
        return stock;
    }    

    // 자동 완성 아닌 고유 메서드
    public void showInfo() {
        System.out.println("제품명 : " + this.getName());          // 부모거라서 getter로 조회
        System.out.println("카테고리 : " + this.getCategory());
        System.out.println("가격 : " + price);                    // 자식거라서 field로 조회
        System.out.println("재고 : " + stock);                
    }
}
```

```java
public static void main(String[] args) {    // 메인 부분
    Item item1 = new Item("일반 상품", "일반 카테고리");

    System.out.println("이 상품은 " + item1.getName()+ "입니다.");
    System.out.println("이 상품은 " + item1.getCategory()+ "입니다.");

    Product product1 = new Product("전자제품", "가전제품", 100000, 10);         // Product 클래스의 인스턴스인 product1을 생성
    product1.setCategory("백색 가전 제품");                                   // setter 이용해서 가전 제품을 백색 가전 제품으로 바꿈
    System.out.println("해당 제품은 " + product1.getCategory() + "입니다.");    // getter를 활용하여 출력
}
```