# 금일 수업 목록
Collection - Map
JSON
Exception / Lambda

---
- key - value 쌍(entry) 삽입 메서드 -> .put(키, 값);
- 입력한 순서대로 출력되지 않음.
-  key 하나당 value는 하나 -> 키가 같다면 value는 가장 최근걸로 덮어쓰기 됨.
- Map 의 경우 순서를 보장하지 않기 때문에 .get("키값"); 을 통해 조회
  - value 값만 나오기 때문에 데이터의 가공이 가능
- .put() : 없는 key 라면 key를 새로 생성해서 value를 초기화
                 있는 key 라면 value 에 재대입
  .replace() : 없는 key 라면 value 값의 갱신이 일어나지 않음
            있는 key 라면 재대입이 일어남
- containsKey() : 특정 key 의 존재 여부 체크. 타입 : boolean
- containsValue() : 특정 value 존재 여부 체크. 타입 : boolean
- Map -> List 직접 변환이 불가능
    -> Map -> Set -> List 로 변환해야함
- key set 출력 -> Set<String> keySet = strMap1.keySet();
- value Set 출력 불가능
  -> 강제 형변환을 하지 않은 상태에서 오류가 발생하는 이유는 
      key 는 중복을 허용하지 x -> set 으로 바꾸는게 가능 
      여러 key 에서 동일한 value가 존재할 수 있기 때문에 직접적으로 Set 으로 바꾸지 않음

### - Map 예시
```java
public static void main(String[] args) {
    Map<String, String> strMap1 = new HashMap<>();
    
    strMap1.put("kor2025001", "김일");
    strMap1.put("kor2025002", "김이");

    strMap1.put("kor2025002", "KimTwo");
    System.out.println(strMap1);

    System.out.println(strMap1.get("kor2025001")+ "님");
    
    Map<String, Double> koreanScores2 = new HashMap<>();
    koreanScores2.put("김일", 98.2);
    koreanScores2.put("김이", 87.2);

    // 특정 key의 value 수정
    koreanScores2.put("김오", 4.5);
    koreanScores2.replace("김오", 76.2);
    System.out.println(koreanScores2);
    
    boolean searchKeyFlag1 = strMap1.containsKey("2025002");
    System.out.println("kor2025002 존재 여부 : " + searchKeyFlag1);
    
    boolean searchValueFlag1 = strMap1.containsValue("김삼");
    System.out.println("김삼 존재 여부 : " + searchValueFlag1);
    
    // Set 내부에 Key가 String, Value가 String인 Map이 통째로 들어간다는 것을 의미
    Set<Map.Entry<String, String>> entrySet1 = new HashSet<>();

    // Key Set 출력
    Set<String> keySet = strMap1.keySet();
    System.out.println(keySet);

    Collection<String> values = strMap1.values();
    System.out.println(values);
}
```

---

# JSON

## 정의
JSON(JavaScript Object Notation) - 본래 자바스크립트 언어로부터 파생되어 자바스크립트 구문을 따르지만, 언어 독립형 데이터 포맷

프로그래밍 언어나 플랫폼에 독립적이기 때문에 구문 분석 및 JSON 데이터 생성을 위한 코드는 Java / Python 등 다양한 언어에서 쉽게 이용 가능

```json
{
  "이름 공간(키)": "값",
  "값 구분자": "각각의 값들은 ',' (콤마)로 구분",
  "이스케이프": "키나 값에서 큰따옴표를 쓰고 싶으면-특정 문자를 이스케이프하려면- \"처럼 문자 앞에 역슬래시를 붙입니다.",
  "자료형": "표현 가능한 자료형은 문자열, 숫자, 불리언, 널, 객체, 배열",
  "문자열값": "나무위키",
  "숫자값": 19721121,
  "불리언값": true,
  "널값": null,
  "객체값(JavaScript식)": {
    "값 1": 3.14159265358979323846264338,
    "값 2": false,
    "값 3": {
      "객체 안에": "객체를 넣는 것도 가능",
      "구분자": "또한 키와 값은 ':'로 구분됩니다"
    }
  },
  "배열값": [
    "이것은 배열입니다.",
    {
      "현재값의 인덱스": 1,
      "이런 식으로": "배열 안에 여러 값을 넣을 수 있습니다."
    },
    [ "배열", "안에", "배열을", "넣는 것도", "가능" ]
  ],
  "값의 개수가 적을 때는": "다음과 같이 한 줄로도 객체와 배열 표현이 가능합니다.",
  "한 줄 객체": { "1": "a", "2": "b", "3": "c" ,  "4": "d" },
  "한 줄 배열": [ "오늘은", "8월", "14일", "목요일", "입니다" ],
  "예시" : "예시입니다."
}

```
mvn검색 -> Gson 복사 -> build.gradle에 붙여넣기

### - JSON 예시
- 속성(키-값 쌍)을 추가하는 메서드 -> addProperty()
- Map 과의 차이
  1. Map 에서는 key 에 "" 가 없었고, 
     JSON 에서는 모든 key에 String 자료형처럼 보이도록 ""가 있습니다.
  2. Map 에서는 key1 = value1 의 형태로 작성되어 있었지만
     JSON 에서는 "key1":value1의 형태로 작성되어 있습니다.
- 콘솔 출력값을 보면 JSON 결과값이 길게 늘어져 있음 -> 가독성을 개선하는 방법으로 출력
  pretty printing : 컴퓨터가 읽기 편한 방식이 아니라 사람이 읽기에 적합한 형태로 출력하는 것
                    외부에서 지원하는 방식 -> GSON
- jsonObject1을 PrettyPrinting이 적용된 JSON 문자열 형태로 반환
  -> gson.toJson(jsonObject명)

```java
public static void main(String[] args) {
    JsonObject jsonObject1 = new JsonObject();
    
    jsonObject1.addProperty("username", 1);
    jsonObject1.addProperty("name", "김일");
    jsonObject1.addProperty("score", 4.5);

    jsonObject1.addProperty("job", "코리아아이티학생");
    System.out.println(jsonObject1);

    Gson gson = new GsonBuilder().setPrettyPrinting().create();
    String jsonData = gson.toJson(jsonObject1);
    System.out.println(jsonData);
}
```

### - JSON 예시 2
- toJson() 이라는 메서드는 argument로 Java Object 자체를 집어 넣는 것도 가능
  Map 으로 생성된 entry를 Json 형태로 바꾸는 것도 가능
  즉, toJson()은 overloading 이 이루어졌다고 볼 수 있음

- json을 Map / Java Object 로 바꾸는 방식
  형식 : gson.fromJson(제이슨데이터, 바꾸고자하는_클래스명.class);

- fromJson() 이라는 메서드명에서 알 수 있듯이 JsonData(즉 String Data)를 Map 으로 바꾸는 것
  String의 경우에는 개행을 통해서 PrettyPrinting이 적용될 수 있지만,
  Map은 toString() 메서드를 재정의 하지 않으면 default값 형태로 콘솔에 출력이 됨
  그래서 gson.fromJson()이든 gsonBuilder.fromJson()이건 콘솔에 찍히는 결과값은 동일하다고 할 수 있음

- Java 객체로 만든 것 -> Json 데이터로 바꾼 다음 -> Map 형태
  하지만 Map의 경우 Json 으로 바꾸는 것까지는 자유인데 걔를 Java 객체로 만들고자 한다면 클래스가 정의되어야 함

- json =/= jsonObject 
  jsonObject의 자료형은 jsonObject

```java
@AllArgsConstructor
@ToString
class User {
    private String userName;
    private String password;
    private String email;
    private String name;
    private String age;
}

public class JSON2 {
    public static void main(String[] args) {
        // 사용할 객체 생성
        Gson gson = new Gson();
        Gson gsonBuilder = new GsonBuilder().setPrettyPrinting().create();
        
        // 1. Java Object -> json 으로 변환
        User user1 = new User("kim1", "9876", "a@test.com", "김일", "20");
        String jsonUser2 = gsonBuilder.toJson(user1);  
        System.out.println(jsonUser2);      
        
        // 2. Map -> json 으로 변환         
        Map<String, String> productMap1 = new HashMap<>();
        productMap1.put("productCode", "MYWY3KH/A");
        productMap1.put("productName", "아이폰 16 프로 맥스");
        String jsonProduct1 = gsonBuilder.toJson(productMap1);
        System.out.println(jsonProduct1);
        
        User user2 = gson.fromJson(jsonUser2, User.class);
        System.out.println(user2);
        Map<String, String> productMap2 = gson.fromJson(jsonProduct2, Map.class);
        System.out.println(productMap2);
        
        Map<String, String> userMap1 = gson.fromJson(jsonUser2, Map.class);
        Map<String, String> userMap2 = gsonBuilder.fromJson(jsonUser2, Map.class);
        System.out.println(userMap1);
        System.out.println(userMap2);
        
        JsonObject jsonObject1 = gson.fromJson(jsonUser1, JsonObject.class);
        System.out.println(jsonObject1);
        JsonObject jsonObject2 = gsonBuilder.fromJson(jsonUser1, JsonObject.class);
        System.out.println(jsonObject2);
    }
}
```

### - 모임 참석자 명단 관리 프로그램 작성 예시
```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    Set<String> attendees = new HashSet<>();
    List<String> meetingList = new ArrayList<>();

    System.out.println("--- 모임 참석자 명단 관리 ---");
    System.out.println("[ 종료 ] 를 입력하면 프로그램을 종료합니다.");
    
    while(true) {       // 이름을 입력받아 Set에 저장, 종료 입력 시 프로그램 종료
        System.out.print("참석자 이름을 입력하세요 >>> ");
        String name = scanner.next();
        if(name.equals("종료")) {
            System.out.println("프로그램이 종료되었습니다.");
            break;
        }
        attendees.add(name);
    }
    System.out.println("\n--- 최종 참석자 명단 ---");
    meetingList.addAll(attendees);      //  Set은 순서가 보장되지 않으므로 출력 불가
    for (int i = 0; i < meetingList.size(); i++) {      // List로 바꿔서 출력
        if(i == (meetingList.size() - 1)) {
            System.out.print(meetingList.get(i));
            break;
        }
        System.out.print(meetingList.get(i) + ", ");
    }
}
```

### -  서점에서 판매하는 책 재고를 관리하는 프로그램 예시
```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    Map<String, Integer> bookInventory = new HashMap<>();

    boolean endOfProgram = false;
    while(!endOfProgram){
        System.out.println("--- 도서 재고 관리 프로그램 ---");
        System.out.println("1. 도서 추가\n2. 재고 수정\n3. 재고 목록\n4. 종료");
        System.out.print("메뉴를 선택하세요 >>> ");
        int option = scanner.nextInt();
        scanner.nextLine();
        switch (option) {
            case 1 :
                System.out.print("새 도서명을 입력하세요 >>> ");
                String bookTitle = scanner.nextLine();
                if (bookInventory.containsKey(bookTitle)) {
                    System.out.println("이미 재고에 있는 도서입니다.");
                } else {
                    System.out.print("재고 수량을 입력하세요 >>> ");
                    int stock = scanner.nextInt();
                    scanner.nextLine();
                    bookInventory.put(bookTitle, stock);
                    System.out.println(bookTitle + " 도서가 " + stock + " 권 추가되었습니다.");
                }
                break;
            case 2 :
                System.out.print("재고를 변경 할 도서명을 입력하세요 >>> ");
                bookTitle = scanner.nextLine();
                if (bookInventory.containsKey(bookTitle)) {
                    System.out.print("새로운 재고 수량을 입력하세요 >>> ");
                    int stock = scanner.nextInt();
                    scanner.nextLine();
                    bookInventory.replace(bookTitle, stock);
                    System.out.println(bookTitle + " 도서가 " + stock + " 권으로 변경되었습니다.");
                } else {
                    System.out.println("해당 도서가 재고에 없습니다.");
                }
                break;
            case 3 :
                System.out.println("--- 현재 재고 목록 ---");
                Set<String> keySet = bookInventory.keySet();
                List<String> keyList = new ArrayList<>();
                keyList.addAll(keySet);     // key 들만 저장된 list를 생성
                for(String key : keyList) {
                    System.out.println("도서명 : " + key + ", 재고 수량 : " + bookInventory.get(key) + "권");
                }
                break;
            case 4 :
                System.out.println("프로그램을 종료합니다.");
                endOfProgram = true;
                break;
        }
    }
}
```